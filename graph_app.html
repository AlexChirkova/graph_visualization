<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä–∞—Ñ–æ–≤</title>
    <style>
        :root {
            --color-primary: #208141;
            --color-primary-hover: #1a6633;
            --color-primary-active: #145029;
            --color-text: #1f2121;
            --color-text-secondary: #626c7c;
            --color-bg: #fcfcf9;
            --color-surface: #ffffff;
            --color-border: #ae5240;
            --color-error: #c0152f;
            --color-success: #208141;
            --color-warning: #a84b2f;
            --focus-ring: 0 0 0 3px rgba(32, 129, 65, 0.4);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: var(--color-bg);
            color: var(--color-text);
        }

        .container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        .toolbar {
            width: 280px;
            background-color: var(--color-surface);
            border-right: 1px solid var(--color-border);
            padding: 16px;
            overflow-y: auto;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
        }

        .toolbar h2 {
            margin: 0 0 16px 0;
            font-size: 18px;
            font-weight: 600;
        }

        .toolbar-section {
            margin-bottom: 24px;
        }

        .toolbar-section h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 500;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn {
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 8px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            background-color: var(--color-surface);
            color: var(--color-text);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 150ms cubic-bezier(0.16, 1, 0.3, 1);
        }

        .btn:hover {
            background-color: rgba(32, 129, 65, 0.08);
            border-color: var(--color-primary);
        }

        .btn:active {
            /* background-color: rgba(32, 129, 65, 0.15); */
            background-color: var(--color-primary);
        }

        .btn:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        .btn.primary {
            background-color: var(--color-primary);
            color: #fcfcf9;
            border-color: var(--color-primary);
        }

        .btn.primary:hover {
            background-color: var(--color-primary-hover);
        }

        .btn.primary:active {
            background-color: var(--color-primary-active);
        }

        .canvas-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .top-toolbar {
            background-color: var(--color-surface);
            border-bottom: 1px solid var(--color-border);
            padding: 12px 16px;
            display: flex;
            gap: 8px;
            align-items: center;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
        }

        .top-toolbar button {
            padding: 8px 12px;
            font-size: 13px;
        }

        canvas {
            flex: 1;
            background-color: var(--color-bg);
            cursor: default;
            display: block;
        }

        .properties-panel {
            width: 250px;
            background-color: var(--color-surface);
            border-left: 1px solid var(--color-border);
            padding: 16px;
            overflow-y: auto;
            box-shadow: -1px 1px 3px rgba(0, 0, 0, 0.04);
        }

        .property-group {
            margin-bottom: 16px;
        }

        .property-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            margin-bottom: 6px;
            letter-spacing: 0.5px;
        }

        .form-control {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            background-color: var(--color-bg);
            color: var(--color-text);
            font-size: 13px;
            font-family: inherit;
            transition: border-color 150ms;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: var(--focus-ring);
        }

        .color-picker {
            width: 100%;
            height: 40px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            cursor: pointer;
        }

        .info-box {
            background-color: rgba(32, 129, 65, 0.08);
            border: 1px solid rgba(32, 129, 65, 0.2);
            border-radius: 6px;
            padding: 12px;
            font-size: 12px;
            line-height: 1.5;
            color: var(--color-text);
        }

        .divider {
            height: 1px;
            background-color: var(--color-border);
            margin: 16px 0;
            opacity: 0.3;
        }

        .status-bar {
            background-color: var(--color-surface);
            border-top: 1px solid var(--color-border);
            padding: 8px 16px;
            font-size: 12px;
            color: var(--color-text-secondary);
            display: flex;
            justify-content: space-between;
        }

        .tooltip {
            position: absolute;
            background-color: rgba(31, 33, 33, 0.9);
            color: #fcfcf9;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 200px;
            word-wrap: break-word;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background-color: var(--color-surface);
            border-radius: 10px;
            padding: 24px;
            max-width: 400px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
        }

        .modal-content h2 {
            margin: 0 0 16px 0;
        }

        .modal-content .form-group {
            margin-bottom: 16px;
        }

        .modal-content label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            font-size: 13px;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .modal-buttons button {
            flex: 1;
            padding: 10px;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- –õ–µ–≤–∞—è –ø–∞–Ω–µ–ª—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ -->
        <div class="toolbar">
            <h2>–ì—Ä–∞—Ñ</h2>

            <div class="toolbar-section">
                <h3>–û–ø–µ—Ä–∞—Ü–∏–∏</h3>
                <button class="btn" id="addVertexBtn" title="–î–æ–±–∞–≤–∏—Ç—å –≤–µ—Ä—à–∏–Ω—É (V)">–î–æ–±–∞–≤–∏—Ç—å –≤–µ—Ä—à–∏–Ω—É</button>
                <button class="btn" id="addEdgeBtn" title="–î–æ–±–∞–≤–∏—Ç—å —Ä–µ–±—Ä–æ (E)">–î–æ–±–∞–≤–∏—Ç—å —Ä–µ–±—Ä–æ</button>
                <button class="btn" id="deleteBtn" title="–£–¥–∞–ª–∏—Ç—å (Del)">–£–¥–∞–ª–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç</button>
                <button class="btn" id="clearBtn" title="–û—á–∏—Å—Ç–∏—Ç—å –≥—Ä–∞—Ñ">–û—á–∏—Å—Ç–∏—Ç—å –≥—Ä–∞—Ñ</button>
            </div>

            <div class="toolbar-section">
                <h3>–ú–∞–∫–µ—Ç</h3>
                <button class="btn" id="forceLayoutBtn">–£–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–π</button>
                <button class="btn" id="circleLayoutBtn">–ö—Ä—É–≥–ª—ã–π</button>
                <button class="btn" id="gridLayoutBtn">–°–µ—Ç–∫–∞</button>
            </div>

            <div class="toolbar-section">
                <h3>–ê–ª–≥–æ—Ä–∏—Ç–º—ã</h3>
                <button class="btn" id="dijkstraBtn">–ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å (–î–µ–π–∫—Å—Ç—Ä–∞)</button>
                <button class="btn" id="bfsBtn">BFS –æ–±—Ö–æ–¥</button>
                <button class="btn" id="dfsBtn">DFS –æ–±—Ö–æ–¥</button>
                <button class="btn" id="clear">Clear</button>
            </div>

            <div class="toolbar-section">
                <h3>–ú–∞—Ç—Ä–∏—Ü–∞</h3>
                <button class="btn" id="loadMatrixBtn">–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑ –º–∞—Ç—Ä–∏—Ü—ã</button>
                <button class="btn" id="saveMatrixBtn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –º–∞—Ç—Ä–∏—Ü—É</button>
            </div>


            <div class="toolbar-section">
                <h3>–§–∞–π–ª</h3>
                <button class="btn" id="saveBtn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å JSON</button>
                <button class="btn" id="loadBtn">–ó–∞–≥—Ä—É–∑–∏—Ç—å JSON</button>
                <button class="btn" id="exportBtn">–≠–∫—Å–ø–æ—Ä—Ç PNG</button>
                <input type="file" id="fileInput" accept=".json" class="hidden">
            </div>

            <div class="divider"></div>
            <div class="info-box">
                <strong>–°–ø—Ä–∞–≤–∫–∞:</strong><br>
                ‚Ä¢ –õ–µ–≤—ã–π –∫–ª–∏–∫ ‚Äî –≤—ã–±—Ä–∞—Ç—å<br>
                ‚Ä¢ –ü—Ä–∞–≤—ã–π –∫–ª–∏–∫ –Ω–∞ –≤–µ—Ä—à–∏–Ω—É ‚Äî —É–¥–∞–ª–∏—Ç—å<br>
                ‚Ä¢ –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ ‚Äî –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ<br>
                ‚Ä¢ –°–∫—Ä–æ–ª–ª ‚Äî –º–∞—Å—à—Ç–∞–±
            </div>
        </div>

        <!-- –†–∞–±–æ—á–∞—è –æ–±–ª–∞—Å—Ç—å -->
        <div class="canvas-wrapper">
            <!-- –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å -->
            <div class="top-toolbar">
                <button class="btn" id="zoomInBtn" title="–£–≤–µ–ª–∏—á–∏—Ç—å (Ctrl++)">üîç+</button>
                <button class="btn" id="zoomOutBtn" title="–£–º–µ–Ω—å—à–∏—Ç—å (Ctrl+-)">üîç‚àí</button>
                <button class="btn" id="resetZoomBtn" title="–°–±—Ä–æ—Å –º–∞—Å—à—Ç–∞–±–∞">–°–±—Ä–æ—Å</button>
                <span id="zoomLevel" style="margin-left: auto; color: var(--color-text-secondary); font-size: 12px;">100%</span>
            </div>

            <!-- Canvas -->
            <canvas id="graphCanvas"></canvas>

            <!-- –°—Ç–∞—Ç—É—Å-–±–∞—Ä -->
            <div class="status-bar">
                <span id="vertexCount">–í–µ—Ä—à–∏–Ω: 0</span>
                <span id="edgeCount">–†—ë–±–µ—Ä: 0</span>
                <span id="mousePos">–ü–æ–∑–∏—Ü–∏—è: ‚Äî</span>
            </div>
        </div>

        <!-- –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å —Å–≤–æ–π—Å—Ç–≤ -->
        <div class="properties-panel">
            <h2 style="margin-top: 0;">–°–≤–æ–π—Å—Ç–≤–∞</h2>

            <div id="noSelection" class="info-box">
                –í—ã–±–µ—Ä–∏—Ç–µ —ç–ª–µ–º–µ–Ω—Ç –≥—Ä–∞—Ñ–∞ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –µ–≥–æ —Å–≤–æ–π—Å—Ç–≤.
            </div>

            <div id="vertexProperties" class="hidden">
                <div class="property-group">
                    <label class="property-label">–ú–µ—Ç–∫–∞ –≤–µ—Ä—à–∏–Ω—ã</label>
                    <input type="text" id="vertexLabel" class="form-control" placeholder="A, B, C...">
                </div>

                <div class="property-group">
                    <label class="property-label">–¶–≤–µ—Ç</label>
                    <input type="color" id="vertexColor" class="color-picker" value="#208141">
                </div>

                <div class="property-group">
                    <label class="property-label">–†–∞–¥–∏—É—Å</label>
                    <input type="number" id="vertexRadius" class="form-control" min="10" max="50" value="25">
                </div>
            </div>

            <div id="edgeProperties" class="hidden">
                <div class="property-group">
                    <label class="property-label">–ú–µ—Ç–∫–∞ —Ä–µ–±—Ä–∞</label>
                    <input type="text" id="edgeLabel" class="form-control" placeholder="–í–µ—Å, —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ...">
                </div>

                <div class="property-group">
                    <label class="property-label">–í–µ—Å</label>
                    <input type="number" id="edgeWeight" class="form-control" min="0" step="0.1" value="1">
                </div>

                <div class="property-group">
                    <label class="property-label">–¶–≤–µ—Ç</label>
                    <input type="color" id="edgeColor" class="color-picker" value="#626c7c">
                </div>

                <div class="property-group">
                    <label class="property-label">–¢–æ–ª—â–∏–Ω–∞</label>
                    <input type="number" id="edgeWidth" class="form-control" min="1" max="5" value="2">
                </div>

                <div class="property-group">
                    <label>
                        <input type="checkbox" id="isDirected"> –û—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ
                    </label>
                </div>
            </div>
        </div>
    </div>

    <!-- –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ -->
     <div id="addVertexModal" class="modal">
        <div class="modal-content">
            <h2>–î–æ–±–∞–≤–∏—Ç—å –≤–µ—Ä—à–∏–Ω—É</h2>
            <div class="form-group">
                <label>–í–≤–µ–¥–∏—Ç–µ –º–µ—Ç–∫—É –≤–µ—Ä—à–∏–Ω—ã:</label>
                <input type="text" id="vertexLabelInput" class="form-control" placeholder="A, B, C..." autofocus>
            </div>
            <div class="modal-buttons">
                <button class="btn" onclick="closeAddVertexModal()">–û—Ç–º–µ–Ω–∞</button>
                <button class="btn primary" onclick="confirmAddVertex()">–î–æ–±–∞–≤–∏—Ç—å</button>
            </div>
        </div>
    </div>
    <div id="dijkstraModal" class="modal">
        <div class="modal-content">
            <h2>–ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å (–î–µ–π–∫—Å—Ç—Ä–∞)</h2>
            <div class="form-group">
                <label>–°—Ç–∞—Ä—Ç–æ–≤–∞—è –≤–µ—Ä—à–∏–Ω–∞:</label>
                <select id="startVertex" class="form-control"></select>
            </div>
            <div class="form-group">
                <label>–ö–æ–Ω–µ—á–Ω–∞—è –≤–µ—Ä—à–∏–Ω–∞:</label>
                <select id="endVertex" class="form-control"></select>
            </div>
            <div class="modal-buttons">
                <button class="btn" onclick="closeDijkstraModal()">–û—Ç–º–µ–Ω–∞</button>
                <button class="btn primary" onclick="runDijkstra()">–ù–∞–π—Ç–∏ –ø—É—Ç—å</button>
            </div>
        </div>
    </div>
    <div id="bfsModal" class="modal">
        <div class="modal-content">
            <h2>BFS –æ–±—Ö–æ–¥</h2>
            <div class="form-group">
                <label>–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∞—Ä—Ç–æ–≤—É—é –≤–µ—Ä—à–∏–Ω—É:</label>
                <select id="bfsStartVertex" class="form-control"></select>
            </div>
            <div class="modal-buttons">
                <button class="btn" onclick="closeBfsModal()">–û—Ç–º–µ–Ω–∞</button>
                <button class="btn primary" onclick="runBFS()">–ù–∞—á–∞—Ç—å –æ–±—Ö–æ–¥</button>
            </div>
        </div>
    </div>
    <div id="dfsModal" class="modal">
        <div class="modal-content">
            <h2>DFS –æ–±—Ö–æ–¥</h2>
            <div class="form-group">
                <label>–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∞—Ä—Ç–æ–≤—É—é –≤–µ—Ä—à–∏–Ω—É:</label>
                <select id="dfsStartVertex" class="form-control"></select>
            </div>
            <div class="modal-buttons">
                <button class="btn" onclick="closeDfsModal()">–û—Ç–º–µ–Ω–∞</button>
                <button class="btn primary" onclick="runDFS()">–ù–∞—á–∞—Ç—å –æ–±—Ö–æ–¥</button>
            </div>
        </div>
    </div>
    <div id="matrixModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <h2>–ó–∞–≥—Ä—É–∑–∏—Ç—å –≥—Ä–∞—Ñ –∏–∑ –º–∞—Ç—Ä–∏—Ü—ã –≤–µ—Å–æ–≤</h2>
            <div class="form-group">
                <label>–í–≤–µ–¥–∏—Ç–µ –º–∞—Ç—Ä–∏—Ü—É –≤–µ—Å–æ–≤ (—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏: –ø—Ä–æ–±–µ–ª/—Ç–∞–±—É–ª—è—Ü–∏—è, —Å—Ç—Ä–æ–∫–∏ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–≤–æ–¥ —Å—Ç—Ä–æ–∫–∏):</label>
                <textarea id="matrixInput" class="form-control" style="height: 250px; font-family: monospace;" placeholder="1 0 5 0&#10;0 2 3 4&#10;5 3 0 1&#10;0 4 1 0"></textarea>
            </div>
            <div class="form-group">
                <label>–ú–µ—Ç–∫–∏ –≤–µ—Ä—à–∏–Ω (—Ä–∞–∑–¥–µ–ª–µ–Ω—ã –∑–∞–ø—è—Ç—ã–º–∏):</label>
                <input type="text" id="vertexLabelsInput" class="form-control" placeholder="A, B, C, D">
            </div>
            <div class="form-group">
                <label>
                    <input type="checkbox" id="isDirectedMatrixInput"> –û—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥—Ä–∞—Ñ
                </label>
            </div>
            <div class="modal-buttons">
                <button class="btn" onclick="closeMatrixModal()">–û—Ç–º–µ–Ω–∞</button>
                <button class="btn primary" onclick="confirmLoadMatrix()">–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
            </div>
        </div>
    </div>


    <script>
        // ============ –ú–û–î–ï–õ–¨ –î–ê–ù–ù–´–• ============
        class Graph {
            constructor() {
                this.vertices = new Map();
                this.edges = [];
            }

            addVertex(id, label = id, x = 0, y = 0, color = '#208141', radius = 25) {
                this.vertices.set(id, { id, label, x, y, color, radius });
            }

            addEdge(from, to, weight = 1, label = '', color = '#626c7c', width = 2, isDirected = false) {
                this.edges.push({ from, to, weight, label, color, width, isDirected });
            }

            removeVertex(id) {
                this.vertices.delete(id);
                this.edges = this.edges.filter(e => e.from !== id && e.to !== id);
            }

            removeEdge(index) {
                this.edges.splice(index, 1);
            }

            clear() {
                this.vertices.clear();
                this.edges = [];
            }

            toJSON() {
                return {
                    vertices: Array.from(this.vertices.values()),
                    edges: this.edges
                };
            }

            fromJSON(data) {
                this.clear();
                data.vertices.forEach(v => {
                    this.addVertex(v.id, v.label, v.x, v.y, v.color || '#208141', v.radius || 25);
                });
                data.edges.forEach(e => {
                    this.addEdge(e.from, e.to, e.weight || 1, e.label || '', e.color || '#626c7c', e.width || 2, e.isDirected || false);
                });
            }
        }

        // ============ –°–û–°–¢–û–Ø–ù–ò–ï –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø ============
        const state = {
            graph: new Graph(),
            mode: 'select', // select, addVertex, addEdge, delete
            selectedVertex: null,
            selectedEdge: null,
            zoom: 1,
            offsetX: 0,
            offsetY: 0,
            isDragging: false,
            dragStartX: 0,
            dragStartY: 0,
            edgeFrom: null,
            highlightedPath: [],
            highlightedVertices: [],
            pendingVertexX: 0, 
            pendingVertexY: 0,
            isPanning: false,
            panStartX: 0,
            panStartY: 0,
            panOffsetX: 0,
            panOffsetY: 0
        };

        // ============ –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ============
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            render();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // ============ –†–ï–ù–î–ï–†–ò–ù–ì ============
        function render() {
            ctx.fillStyle = '#fcfcf9';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(state.zoom, state.zoom);
            ctx.translate(state.offsetX, state.offsetY);

            // –†–∏—Å—É–µ–º —Ä—ë–±—Ä–∞
            state.graph.edges.forEach((edge, index) => {
                drawEdge(edge, index);
            });

            // –†–∏—Å—É–µ–º –≤–µ—Ä—à–∏–Ω—ã
            state.graph.vertices.forEach(vertex => {
                drawVertex(vertex);
            });

            ctx.restore();
        }

        function drawVertex(vertex) {
            const isSelected = state.selectedVertex === vertex.id;
            const isHighlighted = state.highlightedVertices.includes(vertex.id);

            ctx.fillStyle = isHighlighted ? '#a84b2f' : vertex.color;
            ctx.beginPath();
            ctx.arc(vertex.x, vertex.y, vertex.radius, 0, Math.PI * 2);
            ctx.fill();

            if (isSelected) {
                ctx.strokeStyle = '#1f2121';
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.strokeStyle = '#208141';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }

            ctx.fillStyle = '#fcfcf9';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(vertex.label, vertex.x, vertex.y);
        }

        function drawEdge(edge, index) {
            const from = state.graph.vertices.get(edge.from);
            const to = state.graph.vertices.get(edge.to);

            if (!from || !to) return;
/*
            // ===== –ü–ï–¢–õ–Ø (—Ä–µ–±—Ä–æ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã –≤ –Ω–µ—ë —Å–∞–º—É) =====
            if (edge.from === edge.to) {
                const isHighlighted = state.highlightedPath.includes(index);
                const isSelected = state.selectedEdge === index;

                ctx.strokeStyle = isHighlighted ? '#c0152f' : (isSelected ? '#1f2121' : edge.color);
                ctx.lineWidth = isHighlighted ? 4 : (isSelected ? 3 : edge.width);

                const cx = from.x;
                const cy = from.y;
                const r  = from.radius;

                // –ü–µ—Ç–ª—è –∏–¥—ë—Ç –Ω–∞–¥ –≤–µ—Ä—à–∏–Ω–æ–π –ø–æ –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏ —á—É—Ç—å –±–æ–ª—å—à–µ–≥–æ —Ä–∞–¥–∏—É—Å–∞
                const loopRadius = r + 6;          // —á—É—Ç—å –±–æ–ª—å—à–µ –≤–µ—Ä—à–∏–Ω—ã, –ø–æ—á—Ç–∏ ¬´–ø—Ä–∏–ª–∏–ø–∞–µ—Ç¬ª
                const startAngle = Math.PI * 0.15; // —Å–ø—Ä–∞–≤–∞-—Å–Ω–∏–∑—É
                const endAngle   = Math.PI * 0.85; // —Å–ª–µ–≤–∞-—Å–Ω–∏–∑—É

                ctx.beginPath();
                ctx.arc(cx, cy, loopRadius, startAngle, endAngle);
                ctx.stroke();

                // ===== –°—Ç—Ä–µ–ª–∫–∞ –¥–ª—è –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –ø–µ—Ç–ª–∏ =====
                if (edge.isDirected) {
                    const angle = endAngle; // –∫–∞—Å–∞—Ç–µ–ª—å–Ω–∞—è –≤ –∫–æ–Ω—Ü–µ –¥—É–≥–∏
                    const ax = cx + Math.cos(angle) * loopRadius;
                    const ay = cy + Math.sin(angle) * loopRadius;
                    const arrowSize = 10;

                    ctx.fillStyle = edge.color;
                    ctx.beginPath();
                    ctx.moveTo(ax, ay);
                    ctx.lineTo(
                        ax - arrowSize * Math.cos(angle - Math.PI / 6),
                        ay - arrowSize * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.lineTo(
                        ax - arrowSize * Math.cos(angle + Math.PI / 6),
                        ay - arrowSize * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.closePath();
                    ctx.fill();
                }

                // –ú–µ—Ç–∫–∞ –ø–µ—Ç–ª–∏ (–ø–æ —Ü–µ–Ω—Ç—Ä—É –¥—É–≥–∏, —á—É—Ç—å –≤—ã—à–µ –Ω–µ—ë)
                if (edge.label) {
                    const midAngle = (startAngle + endAngle) / 2;
                    const labelRadius = loopRadius + 10;
                    const lx = cx + Math.cos(midAngle) * labelRadius;
                    const ly = cy + Math.sin(midAngle) * labelRadius;

                    ctx.fillStyle = '#1f2121';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(edge.label, lx, ly);
                }

                return;
            }*/

            const isHighlighted = state.highlightedPath.includes(index);
            const isSelected = state.selectedEdge === index;

            ctx.strokeStyle = isHighlighted ? '#c0152f' : (isSelected ? '#1f2121' : edge.color);
            ctx.lineWidth = isHighlighted ? 4 : (isSelected ? 3 : edge.width);

            // –†–∏—Å—É–µ–º –ª–∏–Ω–∏—é
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();

            // –†–∏—Å—É–µ–º —Å—Ç—Ä–µ–ª–∫—É –¥–ª—è –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ä—ë–±–µ—Ä
            if (edge.isDirected) {
                const angle = Math.atan2(to.y - from.y, to.x - from.x);
                const arrowSize = 12;
                const endX = to.x - Math.cos(angle) * (to.radius + 5);
                const endY = to.y - Math.sin(angle) * (to.radius + 5);

                ctx.fillStyle = edge.color;
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - arrowSize * Math.cos(angle - Math.PI / 6), endY - arrowSize * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(endX - arrowSize * Math.cos(angle + Math.PI / 6), endY - arrowSize * Math.sin(angle + Math.PI / 6));
                ctx.closePath();
                ctx.fill();
            }

            // –†–∏—Å—É–µ–º –º–µ—Ç–∫—É —Ä–µ–±—Ä–∞
            if (edge.label) {
                const midX = (from.x + to.x) / 2;
                const midY = (from.y + to.y) / 2;
                ctx.fillStyle = '#1f2121';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(edge.label, midX, midY - 8);
            }
        }

        // ============ –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ============

        // –ö–Ω–æ–ø–∫–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
        document.getElementById('addVertexBtn').addEventListener('click', () => {
        state.mode = state.mode === 'addVertex' ? 'select' : 'addVertex';
        document.getElementById('addVertexBtn').style.opacity = state.mode === 'addVertex' ? '0.5' : '1';
        if (state.mode === 'addVertex') {
            openAddVertexModal();
        }
    });

        document.getElementById('addEdgeBtn').addEventListener('click', () => {
            state.mode = state.mode === 'addEdge' ? 'select' : 'addEdge';
            document.getElementById('addEdgeBtn').style.opacity = state.mode === 'addEdge' ? '0.5' : '1';
            state.edgeFrom = null;
        });

        document.getElementById('deleteBtn').addEventListener('click', () => {
            if (state.selectedVertex) {
                state.graph.removeVertex(state.selectedVertex);
                state.selectedVertex = null;
            } else if (state.selectedEdge !== null) {
                state.graph.removeEdge(state.selectedEdge);
                state.selectedEdge = null;
            }
            updateStatus();
            render();
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            if (confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –æ—Ç–º–µ–Ω–∏—Ç—å.')) {
                state.graph.clear();
                state.selectedVertex = null;
                state.selectedEdge = null;
                state.highlightedPath = [];
                state.highlightedVertices = [];
                updateStatus();
                render();
            }
        });

        // –ú–∞–∫–µ—Ç—ã
        document.getElementById('forceLayoutBtn').addEventListener('click', () => {
            forceDirectedLayout();
            render();
        });

        document.getElementById('circleLayoutBtn').addEventListener('click', () => {
            circleLayout();
            render();
        });

        document.getElementById('gridLayoutBtn').addEventListener('click', () => {
            gridLayout();
            render();
        });

        // –ê–ª–≥–æ—Ä–∏—Ç–º—ã
        document.getElementById('dijkstraBtn').addEventListener('click', openDijkstraModal);
        document.getElementById('bfsBtn').addEventListener('click', openBfsModal);
        document.getElementById('dfsBtn').addEventListener('click', openDfsModal);


        // –ú–∞—Ç—Ä–∏—Ü—ã
        document.getElementById('loadMatrixBtn').addEventListener('click', loadGraphFromMatrix);
        document.getElementById('saveMatrixBtn').addEventListener('click', saveGraphAsMatrix);


        // –§–∞–π–ª—ã
        document.getElementById('saveBtn').addEventListener('click', saveGraph);
        document.getElementById('loadBtn').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });
        document.getElementById('exportBtn').addEventListener('click', exportCanvas);

        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        state.graph.fromJSON(data);
                        state.selectedVertex = null;
                        state.selectedEdge = null;
                        updateStatus();
                        render();
                    } catch (error) {
                        alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
        });

        // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            state.zoom *= 1.2;
            updateZoomDisplay();
            render();
        });

        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            state.zoom /= 1.2;
            updateZoomDisplay();
            render();
        });

        document.getElementById('resetZoomBtn').addEventListener('click', () => {
            state.zoom = 1;
            state.offsetX = 0;
            state.offsetY = 0;
            updateZoomDisplay();
            render();
        });


        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫ –≤ –º–æ–¥–∞–ª—å–Ω—ã—Ö –æ–∫–Ω–∞—Ö
        document.getElementById('vertexLabelInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                confirmAddVertex();
            }
        });

        // Canvas —Å–æ–±—ã—Ç–∏—è
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = (e.clientX - rect.left - canvas.width / 2) / state.zoom - state.offsetX;
            const canvasY = (e.clientY - rect.top - canvas.height / 2) / state.zoom - state.offsetY;

            document.getElementById('mousePos').textContent = `–ü–æ–∑–∏—Ü–∏—è: ${Math.round(canvasX)}, ${Math.round(canvasY)}`;

            if (state.isDragging && state.selectedVertex) {
                const vertex = state.graph.vertices.get(state.selectedVertex);
                vertex.x = canvasX;
                vertex.y = canvasY;
                render();
            }
            else if (state.isPanning) {
                const dx = (e.clientX - state.panStartX) / state.zoom;
                const dy = (e.clientY - state.panStartY) / state.zoom;
                state.offsetX = state.panOffsetX + dx;
                state.offsetY = state.panOffsetY + dy;
                render();
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = (e.clientX - rect.left - canvas.width / 2) / state.zoom - state.offsetX;
            const canvasY = (e.clientY - rect.top - canvas.height / 2) / state.zoom - state.offsetY;

            if (e.button === 2) return; // Right click handled separately

            // –ü–æ–∏—Å–∫ –≤–µ—Ä—à–∏–Ω—ã –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
            let clickedVertex = null;
            for (let [id, vertex] of state.graph.vertices) {
                const dist = Math.hypot(vertex.x - canvasX, vertex.y - canvasY);
                if (dist <= vertex.radius) {
                    clickedVertex = id;
                    break;
                }
            }

            if (state.mode === 'addVertex' && !clickedVertex) {
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
                state.pendingVertexX = canvasX;
                state.pendingVertexY = canvasY;
                openAddVertexModal();
            } else if (state.mode === 'addEdge') {
                if (!state.edgeFrom && clickedVertex) {
                    // –≤—ã–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ä—Ç–æ–≤—É—é –≤–µ—Ä—à–∏–Ω—É –¥–ª—è —Ä–µ–±—Ä–∞
                    state.edgeFrom = clickedVertex;
                } else if (state.edgeFrom && clickedVertex) {
                    // –¥–æ–ø—É—Å–∫–∞–µ–º –ø–µ—Ç–ª—é: from –∏ to –º–æ–≥—É—Ç —Å–æ–≤–ø–∞–¥–∞—Ç—å
                    state.graph.addEdge(state.edgeFrom, clickedVertex, 1, '', '#626c7c', 2, false);
                    state.edgeFrom = null;
                    state.mode = 'select';
                    document.getElementById('addEdgeBtn').style.opacity = '1';
                    updateStatus();
                    render();
                }
            } else if (state.mode === 'select') {
                state.selectedEdge = null;

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª–∏–∫–∞ –ø–æ —Ä—ë–±—Ä–∞–º
                for (let i = 0; i < state.graph.edges.length; i++) {
                    const edge = state.graph.edges[i];
                    const from = state.graph.vertices.get(edge.from);
                    const to = state.graph.vertices.get(edge.to);

                    if (!from || !to) continue;

                    let hit = false;

                    if (edge.from === edge.to) {
                        // –ø–æ–ø–∞–¥–∞–Ω–∏–µ –ø–æ –ø–µ—Ç–ª–µ: –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ü–µ–Ω—Ç—Ä–∞ –≤–µ—Ä—à–∏–Ω—ã
                        const dist = Math.hypot(canvasX - from.x, canvasY - from.y);
                        if (dist > from.radius + 5 && dist < from.radius + 40) {
                            hit = true;
                        }
                    } else {
                        const dist = pointToLineDistance(canvasX, canvasY, from.x, from.y, to.x, to.y);
                        if (dist < 10) {
                            hit = true;
                        }
                    }

                    if (hit) {
                        state.selectedEdge = i;
                        break;
                    }
                }

                if (clickedVertex) {
                    state.selectedVertex = clickedVertex;
                    state.isDragging = true;
                } else {
                    // –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Ö–æ–ª—Å—Ç–∞
                    state.selectedVertex = null;
                    state.isDragging = false;
                    state.isPanning = true;
                    state.panStartX = e.clientX;
                    state.panStartY = e.clientY;
                    state.panOffsetX = state.offsetX;
                    state.panOffsetY = state.offsetY;
                }

                updatePropertiesPanel();
                render();
            }
        });

        canvas.addEventListener('mouseup', () => {
            state.isDragging = false;
            state.isPanning = false;
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const canvasX = (e.clientX - rect.left - canvas.width / 2) / state.zoom - state.offsetX;
            const canvasY = (e.clientY - rect.top - canvas.height / 2) / state.zoom - state.offsetY;

            for (let [id, vertex] of state.graph.vertices) {
                const dist = Math.hypot(vertex.x - canvasX, vertex.y - canvasY);
                if (dist <= vertex.radius) {
                    state.graph.removeVertex(id);
                    state.selectedVertex = null;
                    state.selectedEdge = null;
                    updateStatus();
                    render();
                    return;
                }
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            state.zoom *= zoomFactor;
            state.zoom = Math.max(0.1, Math.min(state.zoom, 5));
            updateZoomDisplay();
            render();
        });

        // –°–≤–æ–π—Å—Ç–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        document.getElementById('vertexLabel').addEventListener('change', (e) => {
            if (state.selectedVertex) {
                state.graph.vertices.get(state.selectedVertex).label = e.target.value;
                render();
            }
        });

        document.getElementById('vertexColor').addEventListener('change', (e) => {
            if (state.selectedVertex) {
                state.graph.vertices.get(state.selectedVertex).color = e.target.value;
                render();
            }
        });

        document.getElementById('vertexRadius').addEventListener('change', (e) => {
            if (state.selectedVertex) {
                state.graph.vertices.get(state.selectedVertex).radius = parseInt(e.target.value);
                render();
            }
        });

        document.getElementById('edgeLabel').addEventListener('change', (e) => {
            if (state.selectedEdge !== null) {
                state.graph.edges[state.selectedEdge].label = e.target.value;
                render();
            }
        });

        document.getElementById('edgeWeight').addEventListener('change', (e) => {
            if (state.selectedEdge !== null) {
                state.graph.edges[state.selectedEdge].weight = parseFloat(e.target.value);
            }
        });

        document.getElementById('edgeColor').addEventListener('change', (e) => {
            if (state.selectedEdge !== null) {
                state.graph.edges[state.selectedEdge].color = e.target.value;
                render();
            }
        });

        document.getElementById('edgeWidth').addEventListener('change', (e) => {
            if (state.selectedEdge !== null) {
                state.graph.edges[state.selectedEdge].width = parseInt(e.target.value);
                render();
            }
        });

        document.getElementById('isDirected').addEventListener('change', (e) => {
            if (state.selectedEdge !== null) {
                state.graph.edges[state.selectedEdge].isDirected = e.target.checked;
                render();
            }
        });

        // ============ –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ============

        function updatePropertiesPanel() {
            const noSelection = document.getElementById('noSelection');
            const vertexProps = document.getElementById('vertexProperties');
            const edgeProps = document.getElementById('edgeProperties');

            noSelection.classList.remove('hidden');
            vertexProps.classList.add('hidden');
            edgeProps.classList.add('hidden');

            if (state.selectedVertex) {
                const vertex = state.graph.vertices.get(state.selectedVertex);
                document.getElementById('vertexLabel').value = vertex.label;
                document.getElementById('vertexColor').value = vertex.color;
                document.getElementById('vertexRadius').value = vertex.radius;

                noSelection.classList.add('hidden');
                vertexProps.classList.remove('hidden');
            } else if (state.selectedEdge !== null) {
                const edge = state.graph.edges[state.selectedEdge];
                document.getElementById('edgeLabel').value = edge.label;
                document.getElementById('edgeWeight').value = edge.weight;
                document.getElementById('edgeColor').value = edge.color;
                document.getElementById('edgeWidth').value = edge.width;
                document.getElementById('isDirected').checked = edge.isDirected;

                noSelection.classList.add('hidden');
                edgeProps.classList.remove('hidden');
            }
        }

        function updateStatus() {
            document.getElementById('vertexCount').textContent = `–í–µ—Ä—à–∏–Ω: ${state.graph.vertices.size}`;
            document.getElementById('edgeCount').textContent = `–†—ë–±–µ—Ä: ${state.graph.edges.length}`;
        }

        function updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = `${Math.round(state.zoom * 100)}%`;
        }

        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;
            let xx, yy;
            if (param < 0) { xx = x1; yy = y1; }
            else if (param > 1) { xx = x2; yy = y2; }
            else { xx = x1 + param * C; yy = y1 + param * D; }
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function openAddVertexModal() {
            const input = document.getElementById('vertexLabelInput');
            input.value = '';
            input.focus();
            document.getElementById('addVertexModal').classList.add('active');
        }

        function closeAddVertexModal() {
            document.getElementById('addVertexModal').classList.remove('active');
            state.mode = 'select';
            document.getElementById('addVertexBtn').style.opacity = '1';
        }

        function confirmAddVertex() {
            const label = document.getElementById('vertexLabelInput').value.trim();

            if (label === '') {
                alert('–ú–µ—Ç–∫–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç–æ–π!');
                return;
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ –º–µ—Ç–∫–∏
            for (let [id, vertex] of state.graph.vertices) {
                if (vertex.label === label) {
                    alert('–í–µ—Ä—à–∏–Ω–∞ —Å —Ç–∞–∫–æ–π –º–µ—Ç–∫–æ–π —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!');
                    return;
                }
            }

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–Ω–∏–∫–∞–ª—å–Ω–æ–≥–æ ID
            let id = label;
            let counter = 1;
            while (state.graph.vertices.has(id)) {
                id = label + counter;
                counter++;
            }

            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤–µ—Ä—à–∏–Ω—ã —Å —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–º–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
            const x = state.pendingVertexX || 0;
            const y = state.pendingVertexY || 0;
            state.graph.addVertex(id, label, x, y);
            state.selectedVertex = id;


            if ((state.pendingVertexX > 150 && state.pendingVertexY < -150)
                || (state.pendingVertexX < -150 && state.pendingVertexY > 150)
            ){
                state.pendingVertexX -= 20;
                state.pendingVertexY += 20;
            }
            else{
                state.pendingVertexX += 20;
                state.pendingVertexY -= 20;
            }
            

            updateStatus();
            render();
            updatePropertiesPanel();
            closeAddVertexModal();
        }


        // ============ –ú–ê–ö–ï–¢–´ ============

        function forceDirectedLayout() {
            const iterations = 100;
            const k = 100;
            const c = 0.1;

            for (let iter = 0; iter < iterations; iter++) {
                const forces = new Map();
                for (let [id] of state.graph.vertices) {
                    forces.set(id, { x: 0, y: 0 });
                }

                // –û—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏–µ –º–µ–∂–¥—É –≤–µ—Ä—à–∏–Ω–∞–º–∏
                const vertices = Array.from(state.graph.vertices.values());
                for (let i = 0; i < vertices.length; i++) {
                    for (let j = i + 1; j < vertices.length; j++) {
                        const v1 = vertices[i];
                        const v2 = vertices[j];
                        const dx = v2.x - v1.x;
                        const dy = v2.y - v1.y;
                        const dist = Math.hypot(dx, dy) + 0.1;
                        const force = (k * k) / dist;
                        forces.get(v1.id).x -= (force * dx) / dist;
                        forces.get(v1.id).y -= (force * dy) / dist;
                        forces.get(v2.id).x += (force * dx) / dist;
                        forces.get(v2.id).y += (force * dy) / dist;
                    }
                }

                // –ü—Ä–∏—Ç—è–∂–µ–Ω–∏–µ –≤–¥–æ–ª—å —Ä—ë–±–µ—Ä
                for (let edge of state.graph.edges) {
                    const v1 = state.graph.vertices.get(edge.from);
                    const v2 = state.graph.vertices.get(edge.to);
                    const dx = v2.x - v1.x;
                    const dy = v2.y - v1.y;
                    const dist = Math.hypot(dx, dy) + 0.1;
                    const force = (dist * dist) / k;
                    forces.get(v1.id).x += (force * dx) / dist;
                    forces.get(v1.id).y += (force * dy) / dist;
                    forces.get(v2.id).x -= (force * dx) / dist;
                    forces.get(v2.id).y -= (force * dy) / dist;
                }

                // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–∏–ª—ã
                for (let [id, vertex] of state.graph.vertices) {
                    const f = forces.get(id);
                    const dist = Math.hypot(f.x, f.y);
                    if (dist > 0) {
                        vertex.x += c * (f.x / dist) * Math.min(dist, 50);
                        vertex.y += c * (f.y / dist) * Math.min(dist, 50);
                    }
                }
            }
        }

        function circleLayout() {
            const vertices = Array.from(state.graph.vertices.values());
            const radius = Math.max(200, vertices.length * 30);
            const center = { x: 0, y: 0 };

            vertices.forEach((vertex, i) => {
                const angle = (i / vertices.length) * Math.PI * 2;
                vertex.x = center.x + Math.cos(angle) * radius;
                vertex.y = center.y + Math.sin(angle) * radius;
            });
        }

        function gridLayout() {
            const vertices = Array.from(state.graph.vertices.values());
            const cols = Math.ceil(Math.sqrt(vertices.length));
            const spacing = 150;

            vertices.forEach((vertex, i) => {
                vertex.x = (i % cols - cols / 2) * spacing;
                vertex.y = (Math.floor(i / cols) - cols / 2) * spacing;
            });
        }

        // ============ –ê–õ–ì–û–†–ò–¢–ú–´ ============

        function openDijkstraModal() {
            if (state.graph.vertices.size < 2) {
                alert('–ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 2 –≤–µ—Ä—à–∏–Ω—ã');
                return;
            }

            const select1 = document.getElementById('startVertex');
            const select2 = document.getElementById('endVertex');
            select1.innerHTML = '';
            select2.innerHTML = '';

            for (let [id, vertex] of state.graph.vertices) {
                const opt1 = document.createElement('option');
                opt1.value = id;
                opt1.textContent = vertex.label || id;
                select1.appendChild(opt1);

                const opt2 = document.createElement('option');
                opt2.value = id;
                opt2.textContent = vertex.label || id;
                select2.appendChild(opt2);
            }

            document.getElementById('dijkstraModal').classList.add('active');
        }

        function closeDijkstraModal() {
            document.getElementById('dijkstraModal').classList.remove('active');
        }

        function runDijkstra() {
            const start = document.getElementById('startVertex').value;
            const end = document.getElementById('endVertex').value;

            const distances = new Map();
            const previous = new Map();
            const unvisited = new Set();

            for (let [id] of state.graph.vertices) {
                distances.set(id, id === start ? 0 : Infinity);
                previous.set(id, null);
                unvisited.add(id);
            }

            while (unvisited.size > 0) {
                let current = null;
                let minDist = Infinity;

                for (let id of unvisited) {
                    if (distances.get(id) < minDist) {
                        minDist = distances.get(id);
                        current = id;
                    }
                }

                if (current === null || distances.get(current) === Infinity) break;

                unvisited.delete(current);

                for (let edge of state.graph.edges) {
                    if (edge.from === current && unvisited.has(edge.to)) {
                        const alt = distances.get(current) + edge.weight;
                        if (alt < distances.get(edge.to)) {
                            distances.set(edge.to, alt);
                            previous.set(edge.to, current);
                        }
                    }
                }
            }

            // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É—Ç–∏
            const path = [];
            let current = end;
            while (current !== null) {
                path.unshift(current);
                current = previous.get(current);
            }

            if (path[0] !== start) {
                alert('–ü—É—Ç–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç');
                closeDijkstraModal();
                return;
            }

            state.highlightedVertices = path;
            state.highlightedPath = [];

            for (let i = 0; i < path.length - 1; i++) {
                for (let j = 0; j < state.graph.edges.length; j++) {
                    const edge = state.graph.edges[j];
                    if ((edge.from === path[i] && edge.to === path[i + 1]) ||
                        (!edge.isDirected && edge.from === path[i + 1] && edge.to === path[i])) {
                        state.highlightedPath.push(j);
                        break;
                    }
                }
            }

            alert(`–ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å –Ω–∞–π–¥–µ–Ω!\n–î–∏—Å—Ç–∞–Ω—Ü–∏—è: ${distances.get(end)}\n–ü—É—Ç—å: ${path.join(' ‚Üí ')}`);
            closeDijkstraModal();
            render();
        }

        function openBfsModal() {
            if (state.graph.vertices.size < 1) {
                alert('–ì—Ä–∞—Ñ –ø—É—Å—Ç');
                return;
            }

            const select = document.getElementById('bfsStartVertex');
            select.innerHTML = '';

            for (let [id, vertex] of state.graph.vertices) {
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = vertex.label || id;
                select.appendChild(opt);
            }

            document.getElementById('bfsModal').classList.add('active');
        }

        function closeBfsModal() {
            document.getElementById('bfsModal').classList.remove('active');
        }

        function runBFS() {
            const start = document.getElementById('bfsStartVertex').value;
            const visited = new Set();
            const queue = [start];
            const order = [];

            while (queue.length > 0) {
                const current = queue.shift();
                if (visited.has(current)) continue;
                visited.add(current);
                order.push(current);

                for (let edge of state.graph.edges) {
                    if (edge.from === current && !visited.has(edge.to)) {
                        queue.push(edge.to);
                    } else if (!edge.isDirected && edge.to === current && !visited.has(edge.from)) {
                        queue.push(edge.from);
                    }
                }
            }

            state.highlightedVertices = order;
            state.highlightedPath = [];
            const pathStr = order.map(id => state.graph.vertices.get(id).label || id).join(' ‚Üí ');
            alert('BFS –æ–±—Ö–æ–¥: ' + pathStr);
            closeBfsModal();
            render();
        }

        function openDfsModal() {
            if (state.graph.vertices.size < 1) {
                alert('–ì—Ä–∞—Ñ –ø—É—Å—Ç');
                return;
            }

            const select = document.getElementById('dfsStartVertex');
            select.innerHTML = '';

            for (let [id, vertex] of state.graph.vertices) {
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = vertex.label || id;
                select.appendChild(opt);
            }

            document.getElementById('dfsModal').classList.add('active');
        }

        function closeDfsModal() {
            document.getElementById('dfsModal').classList.remove('active');
        }

        function runDFS() {
            const start = document.getElementById('dfsStartVertex').value;
            const visited = new Set();
            const order = [];

            function dfs(vertex) {
                visited.add(vertex);
                order.push(vertex);

                for (let edge of state.graph.edges) {
                    if (edge.from === vertex && !visited.has(edge.to)) {
                        dfs(edge.to);
                    } else if (!edge.isDirected && edge.to === vertex && !visited.has(edge.from)) {
                        dfs(edge.from);
                    }
                }
            }

            dfs(start);

            state.highlightedVertices = order;
            state.highlightedPath = [];
            const pathStr = order.map(id => state.graph.vertices.get(id).label || id).join(' ‚Üí ');
            alert('DFS –æ–±—Ö–æ–¥: ' + pathStr);
            closeDfsModal();
            render();
        }

        // ============ –§–ê–ô–õ–´ ============

        function saveGraph() {
            // –î–∏–∞–ª–æ–≥ –¥–ª—è –≤–≤–æ–¥–∞ –Ω–∞–∑–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞
            const filename = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞:', 'graph');
            if (filename === null) return; // –û—Ç–º–µ–Ω–∞

            const data = state.graph.toJSON();
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename.trim() === '' ? 'graph.json' : filename + '.json'; // –ï—Å–ª–∏ –ø—É—Å—Ç–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º 'graph.json'
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportCanvas() {
            // –î–∏–∞–ª–æ–≥ –¥–ª—è –≤–≤–æ–¥–∞ –Ω–∞–∑–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞
            const filename = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞:', 'graph');
            if (filename === null) return; // –û—Ç–º–µ–Ω–∞

            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = filename.trim() === '' ? 'graph.png' : filename + '.png'; // –ï—Å–ª–∏ –ø—É—Å—Ç–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º 'graph.png'
            link.click();
        }

        // ============ –†–ê–ë–û–¢–ê –° –ú–ê–¢–†–ò–¶–ï–ô –í–ï–°–û–í ============

        function openMatrixModal() {
            document.getElementById('matrixInput').value = '';
            document.getElementById('vertexLabelsInput').value = '';
            document.getElementById('isDirectedMatrixInput').checked = false;
            document.getElementById('matrixModal').classList.add('active');
        }

        function closeMatrixModal() {
            document.getElementById('matrixModal').classList.remove('active');
        }

        function confirmLoadMatrix() {
            const matrixText = document.getElementById('matrixInput').value.trim();
            const labelsText = document.getElementById('vertexLabelsInput').value.trim();
            const isDirected = document.getElementById('isDirectedMatrixInput').checked;

            if (!matrixText) {
                alert('–í–≤–µ–¥–∏—Ç–µ –º–∞—Ç—Ä–∏—Ü—É –≤–µ—Å–æ–≤');
                return;
            }

            try {
                // –ü–∞—Ä—Å–∏–Ω–≥ –º–∞—Ç—Ä–∏—Ü—ã
                const lines = matrixText.split('\n').map(line => 
                    line.trim().split(/\s+/).map(Number)
                ).filter(line => line.length > 0);

                const size = lines.length;

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –º–∞—Ç—Ä–∏—Ü—ã
                for (let line of lines) {
                    if (line.length !== size) {
                        alert('–ú–∞—Ç—Ä–∏—Ü–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∫–≤–∞–¥—Ä–∞—Ç–Ω–æ–π!');
                        return;
                    }
                }

                // –ü–∞—Ä—Å–∏–Ω–≥ –º–µ—Ç–∞–∫ –≤–µ—Ä—à–∏–Ω
                const labels = labelsText ? 
                    labelsText.split(',').map(l => l.trim()) : 
                    Array.from({length: size}, (_, i) => `V${i}`);

                if (labels.length !== size) {
                    alert(`–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Ç–∞–∫ (${labels.length}) –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å —Ä–∞–∑–º–µ—Ä–æ–º –º–∞—Ç—Ä–∏—Ü—ã (${size})`);
                    return;
                }

                // –û—á–∏—Å—Ç–∫–∞ –≥—Ä–∞—Ñ–∞
                state.graph.clear();
                state.selectedVertex = null;
                state.selectedEdge = null;
                state.highlightedPath = [];
                state.highlightedVertices = [];

                // –°–æ–∑–¥–∞–Ω–∏–µ –≤–µ—Ä—à–∏–Ω
                for (let i = 0; i < size; i++) {
                    state.graph.addVertex(i.toString(), labels[i], i * 100 - (size * 50), 0);
                }

                // –°–æ–∑–¥–∞–Ω–∏–µ —Ä—ë–±–µ—Ä –∏–∑ –º–∞—Ç—Ä–∏—Ü—ã
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        const weight = lines[i][j];
                        if (weight !== 0 && weight !== undefined) {
                            // –î–ª—è –Ω–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞ –∏–∑–±–µ–≥–∞–µ–º –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
                            if (isDirected || i <= j) {
                                state.graph.addEdge(i.toString(), j.toString(), weight, 
                                                weight.toString(), '#626c7c', 2, isDirected);
                            }
                        }
                    }
                }

                updateStatus();
                render();
                closeMatrixModal();
                alert('–ì—Ä–∞—Ñ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω –∏–∑ –º–∞—Ç—Ä–∏—Ü—ã');

            } catch (error) {
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ –º–∞—Ç—Ä–∏—Ü—ã: ' + error.message);
            }
        }

        function loadGraphFromMatrix() {
            openMatrixModal();
        }

        function saveGraphAsMatrix() {
            const vertices = Array.from(state.graph.vertices.values());
            const size = vertices.length;

            if (size === 0) {
                alert('–ì—Ä–∞—Ñ –ø—É—Å—Ç');
                return;
            }

            // –°–æ–∑–¥–∞–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã
            const matrix = Array(size).fill(null).map(() => Array(size).fill(0));

            // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –≤–µ—Å–∞–º–∏
            for (let edge of state.graph.edges) {
                const fromIdx = Array.from(state.graph.vertices.keys()).indexOf(edge.from);
                const toIdx = Array.from(state.graph.vertices.keys()).indexOf(edge.to);

                if (fromIdx !== -1 && toIdx !== -1) {
                    matrix[fromIdx][toIdx] = edge.weight;

                    // –î–ª—è –Ω–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ä—ë–±–µ—Ä –¥–æ–±–∞–≤–ª—è–µ–º —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                    if (!edge.isDirected) {
                        matrix[toIdx][fromIdx] = edge.weight;
                    }
                }
            }

            // –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –≤ —Å—Ç—Ä–æ–∫—É
            let matrixText = '–ú–∞—Ç—Ä–∏—Ü–∞ –≤–µ—Å–æ–≤ –≥—Ä–∞—Ñ–∞\n';
            matrixText += '–í–µ—Ä—à–∏–Ω—ã: ' + vertices.map(v => v.label).join(', ') + '\n\n';

            for (let i = 0; i < size; i++) {
                matrixText += matrix[i].map(val => 
                    val === 0 ? '0' : val.toFixed(2)
                ).join('\t') + '\n';
            }

            // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ —Ñ–∞–π–ª
            const filename = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞:', 'graph_matrix');
            if (filename === null) return;

            const blob = new Blob([matrixText], { type: 'text/plain; charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename.trim() === '' ? 'graph_matrix.txt' : filename + '.txt';
            a.click();
            URL.revokeObjectURL(url);

            alert('–ú–∞—Ç—Ä–∏—Ü–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ —Ñ–∞–π–ª');
        }



        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        updateStatus();
        updateZoomDisplay();
    </script>
</body>
</html>
