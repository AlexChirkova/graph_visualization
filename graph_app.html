<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä–∞—Ñ–æ–≤</title>
    <style>
        :root {
            --color-primary: #208141;
            --color-primary-hover: #1a6633;
            --color-primary-active: #145029;
            --color-text: #1f2121;
            --color-text-secondary: #626c7c;
            --color-bg: #fcfcf9;
            --color-surface: #ffffff;
            --color-border: #ae5240;
            --color-error: #c0152f;
            --color-success: #208141;
            --color-warning: #a84b2f;
            --focus-ring: 0 0 0 3px rgba(32, 129, 65, 0.4);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: var(--color-bg);
            color: var(--color-text);
        }

        .container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        .toolbar {
            width: 280px;
            background-color: var(--color-surface);
            border-right: 1px solid var(--color-border);
            padding: 16px;
            overflow-y: auto;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
        }

        .toolbar h2 {
            margin: 0 0 16px 0;
            font-size: 18px;
            font-weight: 600;
        }

        .toolbar-section {
            margin-bottom: 24px;
        }

        .toolbar-section h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 500;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn {
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 8px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            background-color: var(--color-surface);
            color: var(--color-text);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 150ms cubic-bezier(0.16, 1, 0.3, 1);
        }

        .btn:hover {
            background-color: rgba(32, 129, 65, 0.08);
            border-color: var(--color-primary);
        }

        .btn:active {
            /* background-color: rgba(32, 129, 65, 0.15); */
            background-color: var(--color-primary);
        }

        .btn:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        .btn.primary {
            background-color: var(--color-primary);
            color: #fcfcf9;
            border-color: var(--color-primary);
        }

        .btn.primary:hover {
            background-color: var(--color-primary-hover);
        }

        .btn.primary:active {
            background-color: var(--color-primary-active);
        }

        .canvas-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .top-toolbar {
            background-color: var(--color-surface);
            border-bottom: 1px solid var(--color-border);
            padding: 12px 16px;
            display: flex;
            gap: 8px;
            align-items: center;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
        }

        .top-toolbar button {
            padding: 8px 12px;
            font-size: 13px;
        }

        canvas {
            flex: 1;
            background-color: var(--color-bg);
            cursor: default;
            display: block;
        }

        .properties-panel {
            width: 250px;
            background-color: var(--color-surface);
            border-left: 1px solid var(--color-border);
            padding: 16px;
            overflow-y: auto;
            box-shadow: -1px 1px 3px rgba(0, 0, 0, 0.04);
        }

        .property-group {
            margin-bottom: 16px;
        }

        .property-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            margin-bottom: 6px;
            letter-spacing: 0.5px;
        }

        .form-control {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            background-color: var(--color-bg);
            color: var(--color-text);
            font-size: 13px;
            font-family: inherit;
            transition: border-color 150ms;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: var(--focus-ring);
        }

        .color-picker {
            width: 100%;
            height: 40px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            cursor: pointer;
        }

        .info-box {
            background-color: rgba(32, 129, 65, 0.08);
            border: 1px solid rgba(32, 129, 65, 0.2);
            border-radius: 6px;
            padding: 12px;
            font-size: 12px;
            line-height: 1.5;
            color: var(--color-text);
        }

        .divider {
            height: 1px;
            background-color: var(--color-border);
            margin: 16px 0;
            opacity: 0.3;
        }

        .status-bar {
            background-color: var(--color-surface);
            border-top: 1px solid var(--color-border);
            padding: 8px 16px;
            font-size: 12px;
            color: var(--color-text-secondary);
            display: flex;
            justify-content: space-between;
        }

        .tooltip {
            position: absolute;
            background-color: rgba(31, 33, 33, 0.9);
            color: #fcfcf9;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 200px;
            word-wrap: break-word;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background-color: var(--color-surface);
            border-radius: 10px;
            padding: 24px;
            max-width: 400px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
        }

        .modal-content h2 {
            margin: 0 0 16px 0;
        }

        .modal-content .form-group {
            margin-bottom: 16px;
        }

        .modal-content label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            font-size: 13px;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .modal-buttons button {
            flex: 1;
            padding: 10px;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- –õ–µ–≤–∞—è –ø–∞–Ω–µ–ª—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ -->
        <div class="toolbar">
            <h2>–ì—Ä–∞—Ñ</h2>

            <div class="toolbar-section">
                <h3>–û–ø–µ—Ä–∞—Ü–∏–∏</h3>
                <button class="btn" id="addVertexBtn" title="–î–æ–±–∞–≤–∏—Ç—å –≤–µ—Ä—à–∏–Ω—É (V)">–î–æ–±–∞–≤–∏—Ç—å –≤–µ—Ä—à–∏–Ω—É</button>
                <button class="btn" id="addEdgeBtn" title="–î–æ–±–∞–≤–∏—Ç—å —Ä–µ–±—Ä–æ (E)">–î–æ–±–∞–≤–∏—Ç—å —Ä–µ–±—Ä–æ</button>
                <button class="btn" id="deleteBtn" title="–£–¥–∞–ª–∏—Ç—å (Del)">–£–¥–∞–ª–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç</button>
                <button class="btn" id="clearBtn" title="–û—á–∏—Å—Ç–∏—Ç—å –≥—Ä–∞—Ñ">–û—á–∏—Å—Ç–∏—Ç—å –≥—Ä–∞—Ñ</button>
            </div>

            <div class="toolbar-section">
                <h3>–ú–∞–∫–µ—Ç</h3>
                <button class="btn" id="forceLayoutBtn">–£–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–π</button>
                <button class="btn" id="circleLayoutBtn">–ö—Ä—É–≥–ª—ã–π</button>
                <button class="btn" id="gridLayoutBtn">–°–µ—Ç–∫–∞</button>
                <button class="btn" id="treeLayoutBtn">–î–µ—Ä–µ–≤–æ</button>
            </div>

            <div class="toolbar-section">
                <h3>–ê–ª–≥–æ—Ä–∏—Ç–º—ã</h3>
                <button class="btn" id="dijkstraBtn">–ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å (–î–µ–π–∫—Å—Ç—Ä–∞)</button>
                <button class="btn" id="bfsBtn">BFS –æ–±—Ö–æ–¥</button>
                <button class="btn" id="dfsBtn">DFS –æ–±—Ö–æ–¥</button>
                <button class="btn" id="componentsBtn">–ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Å–≤—è–∑–Ω–æ—Å—Ç–∏</button>
                <button class="btn" id="cutVertexBtn">–®–∞—Ä–Ω–∏—Ä—ã</button>
                <button class="btn" id="bridgeBtn">–ú–æ—Å—Ç—ã</button>
            </div>

            <div class="toolbar-section">
                <h3>–ú–∞—Ç—Ä–∏—Ü–∞</h3>
                <button class="btn" id="loadMatrixBtn">–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑ –º–∞—Ç—Ä–∏—Ü—ã</button>
                <button class="btn" id="saveMatrixBtn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –º–∞—Ç—Ä–∏—Ü—É</button>
            </div>


            <div class="toolbar-section">
                <h3>–§–∞–π–ª</h3>
                <button class="btn" id="saveBtn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å JSON</button>
                <button class="btn" id="loadBtn">–ó–∞–≥—Ä—É–∑–∏—Ç—å JSON</button>
                <button class="btn" id="exportBtn">–≠–∫—Å–ø–æ—Ä—Ç PNG</button>
                <input type="file" id="fileInput" accept=".json" class="hidden">
            </div>
        </div>

        <!-- –†–∞–±–æ—á–∞—è –æ–±–ª–∞—Å—Ç—å -->
        <div class="canvas-wrapper">
            <!-- –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å -->
            <div class="top-toolbar">
                <button class="btn" id="zoomInBtn" title="–£–≤–µ–ª–∏—á–∏—Ç—å (Ctrl++)">üîç+</button>
                <button class="btn" id="zoomOutBtn" title="–£–º–µ–Ω—å—à–∏—Ç—å (Ctrl+-)">üîç‚àí</button>
                <button class="btn" id="resetZoomBtn" title="–°–±—Ä–æ—Å –º–∞—Å—à—Ç–∞–±–∞">–°–±—Ä–æ—Å</button>
                <span id="zoomLevel" style="margin-left: auto; color: var(--color-text-secondary); font-size: 12px;">100%</span>
            </div>

            <!-- Canvas -->
            <canvas id="graphCanvas"></canvas>

            <!-- –°—Ç–∞—Ç—É—Å-–±–∞—Ä -->
            <div class="status-bar">
                <span id="vertexCount">–í–µ—Ä—à–∏–Ω: 0</span>
                <span id="edgeCount">–†—ë–±–µ—Ä: 0</span>
                <span id="mousePos">–ü–æ–∑–∏—Ü–∏—è: ‚Äî</span>
            </div>
        </div>

        <!-- –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å —Å–≤–æ–π—Å—Ç–≤ -->
        <div class="properties-panel">
            <h2 style="margin-top: 0;">–°–≤–æ–π—Å—Ç–≤–∞</h2>

            <div id="noSelection" class="info-box">
                –í—ã–±–µ—Ä–∏—Ç–µ —ç–ª–µ–º–µ–Ω—Ç –≥—Ä–∞—Ñ–∞ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –µ–≥–æ —Å–≤–æ–π—Å—Ç–≤.
            </div>
            <div class="divider"></div>
            <div class="info-box">
                <strong>–°–ø—Ä–∞–≤–∫–∞:</strong><br>
                ‚Ä¢ –õ–µ–≤—ã–π –∫–ª–∏–∫ ‚Äî –≤—ã–±—Ä–∞—Ç—å<br>
                ‚Ä¢ –ü—Ä–∞–≤—ã–π –∫–ª–∏–∫ –Ω–∞ –≤–µ—Ä—à–∏–Ω—É ‚Äî —É–¥–∞–ª–∏—Ç—å<br>
                ‚Ä¢ –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ ‚Äî –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ<br>
                ‚Ä¢ –°–∫—Ä–æ–ª–ª ‚Äî –º–∞—Å—à—Ç–∞–± <br>
                ‚Ä¢ Shift ‚Äî –æ—Ç–∫–ª—é—á–∏—Ç—å –ø–æ–¥—Å–≤–µ—Ç–∫—É –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
            </div>

            <div id="vertexProperties" class="hidden">
                <div class="property-group">
                    <label class="property-label">–ú–µ—Ç–∫–∞ –≤–µ—Ä—à–∏–Ω—ã</label>
                    <input type="text" id="vertexLabel" class="form-control" placeholder="A, B, C...">
                </div>

                <div class="property-group">
                    <label class="property-label">–¶–≤–µ—Ç</label>
                    <input type="color" id="vertexColor" class="color-picker" value="#208141">
                </div>

                <div class="property-group">
                    <label class="property-label">–†–∞–¥–∏—É—Å</label>
                    <input type="number" id="vertexRadius" class="form-control" min="10" max="50" value="25">
                </div>
            </div>

            <div id="edgeProperties" class="hidden">
                <div class="property-group">
                    <label class="property-label">–ú–µ—Ç–∫–∞ —Ä–µ–±—Ä–∞</label>
                    <input type="text" id="edgeLabel" class="form-control" placeholder="–í–µ—Å, —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ...">
                </div>

                <div class="property-group">
                    <label class="property-label">–í–µ—Å</label>
                    <input type="number" id="edgeWeight" class="form-control" min="0" step="0.1" value="1">
                </div>

                <div class="property-group">
                    <label class="property-label">–¶–≤–µ—Ç</label>
                    <input type="color" id="edgeColor" class="color-picker" value="#626c7c">
                </div>

                <div class="property-group">
                    <label class="property-label">–¢–æ–ª—â–∏–Ω–∞</label>
                    <input type="number" id="edgeWidth" class="form-control" min="1" max="5" value="2">
                </div>

                <div class="property-group">
                    <label>
                        <input type="checkbox" id="isDirected"> –û—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ
                    </label>
                </div>
            </div>
        </div>
    </div>

    <!-- –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ -->
    <!--–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤–µ—Ä—à–∏–Ω—ã-->
     <div id="addVertexModal" class="modal">
        <div class="modal-content">
            <h2>–î–æ–±–∞–≤–∏—Ç—å –≤–µ—Ä—à–∏–Ω—É</h2>
            <div class="form-group">
                <label>–í–≤–µ–¥–∏—Ç–µ –º–µ—Ç–∫—É –≤–µ—Ä—à–∏–Ω—ã:</label>
                <input type="text" id="vertexLabelInput" class="form-control" placeholder="A, B, C..." autofocus>
            </div>
            <div class="modal-buttons">
                <button class="btn" onclick="closeAddVertexModal()">–û—Ç–º–µ–Ω–∞</button>
                <button class="btn primary" onclick="confirmAddVertex()">–î–æ–±–∞–≤–∏—Ç—å</button>
            </div>
        </div>
    </div>
    <!--–î–µ—Ä–µ–≤–æ-->
    <div id="treeModal" class="modal">
        <div class="modal-content">
            <h2>–î–µ—Ä–µ–≤–æ</h2>
            <div class="form-group">
            <label>–í—ã–±–µ—Ä–∏—Ç–µ –≤–µ—Ä—à–∏–Ω—É-–∫–æ—Ä–µ–Ω—å:</label>
            <select id="treeRootVertex" class="form-control"></select>
            </div>
            <div class="modal-buttons">
            <button class="btn" onclick="closeTreeModal()">–û—Ç–º–µ–Ω–∞</button>
            <button class="btn primary" onclick="applyTreeLayout()">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
            </div>
        </div>
    </div>
    <!--–ê–ª–≥–æ—Ä–∏—Ç–º—ã –æ–±—Ö–æ–¥–∞-->
    <div id="dijkstraModal" class="modal">
        <div class="modal-content">
            <h2>–ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å (–î–µ–π–∫—Å—Ç—Ä–∞)</h2>
            <div class="form-group">
                <label>–°—Ç–∞—Ä—Ç–æ–≤–∞—è –≤–µ—Ä—à–∏–Ω–∞:</label>
                <select id="startVertex" class="form-control"></select>
            </div>
            <div class="form-group">
                <label>–ö–æ–Ω–µ—á–Ω–∞—è –≤–µ—Ä—à–∏–Ω–∞:</label>
                <select id="endVertex" class="form-control"></select>
            </div>
            <div class="form-group">
                <label>–†–µ–∂–∏–º:</label>
                <select id="djModeSelect" class="form-control">
                    <option value="space">–®–∞–≥ –ø–æ –ø—Ä–æ–±–µ–ª—É</option>
                    <option value="auto">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ —Ç–∞–π–º–µ—Ä—É</option>
                </select>
                </div>
                <div class="form-group">
                <label>–ò–Ω—Ç–µ—Ä–≤–∞–ª (—Å–µ–∫):</label>
                <input type="number" id="djDelayInput" class="form-control"
                        min="0.1" step="0.1" value="1">
                </div>
            <div class="modal-buttons">
                <button class="btn" onclick="closeDijkstraModal()">–û—Ç–º–µ–Ω–∞</button>
                <button class="btn primary" onclick="startDijkstraVisualization()">–ù–∞–π—Ç–∏ –ø—É—Ç—å</button>
            </div>
        </div>
    </div>
    <div id="bfsModal" class="modal">
        <div class="modal-content">
            <h2>BFS –æ–±—Ö–æ–¥</h2>
            <div class="form-group">
                <label>–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∞—Ä—Ç–æ–≤—É—é –≤–µ—Ä—à–∏–Ω—É:</label>
                <select id="bfsStartVertex" class="form-control"></select>
            </div>
            <div class="form-group">
                <label>–†–µ–∂–∏–º:</label>
                <select id="bfsModeSelect" class="form-control">
                    <option value="space">–®–∞–≥ –ø–æ –ø—Ä–æ–±–µ–ª—É</option>
                    <option value="auto">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ —Ç–∞–π–º–µ—Ä—É</option>
                </select>
                </div>
                <div class="form-group">
                <label>–ò–Ω—Ç–µ—Ä–≤–∞–ª (—Å–µ–∫—É–Ω–¥—ã, –¥–ª—è –∞–≤—Ç–æ):</label>
                <input type="number" id="bfsDelayInput" class="form-control"
                        min="0.1" step="0.1" value="1">
                </div>
            <div class="modal-buttons">
                <button class="btn" onclick="closeBfsModal()">–û—Ç–º–µ–Ω–∞</button>
                <button class="btn primary" onclick="startBfsVisualization()">–ù–∞—á–∞—Ç—å –æ–±—Ö–æ–¥</button>
            </div>
        </div>
    </div>
    <div id="dfsModal" class="modal">
        <div class="modal-content">
            <h2>DFS –æ–±—Ö–æ–¥</h2>
            <div class="form-group">
                <label>–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∞—Ä—Ç–æ–≤—É—é –≤–µ—Ä—à–∏–Ω—É:</label>
                <select id="dfsStartVertex" class="form-control"></select>
            </div>
            <div class="form-group">
                <label>–†–µ–∂–∏–º:</label>
                <select id="dfsModeSelect" class="form-control">
                    <option value="space">–®–∞–≥ –ø–æ –ø—Ä–æ–±–µ–ª—É</option>
                    <option value="auto">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ —Ç–∞–π–º–µ—Ä—É</option>
                </select>
                </div>
                <div class="form-group">
                <label>–ò–Ω—Ç–µ—Ä–≤–∞–ª (—Å–µ–∫):</label>
                <input type="number" id="dfsDelayInput" class="form-control"
                        min="0.1" step="0.1" value="1">
                </div>
            <div class="modal-buttons">
                <button class="btn" onclick="closeDfsModal()">–û—Ç–º–µ–Ω–∞</button>
                <button class="btn primary" onclick="startDfsVisualization()">–ù–∞—á–∞—Ç—å –æ–±—Ö–æ–¥</button>
            </div>
        </div>
    </div>
    <!--–°–æ–∑–¥–∞–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –≤–µ—Å–æ–≤-->
    <div id="matrixModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <h2>–ó–∞–≥—Ä—É–∑–∏—Ç—å –≥—Ä–∞—Ñ –∏–∑ –º–∞—Ç—Ä–∏—Ü—ã –≤–µ—Å–æ–≤</h2>
            <div class="form-group">
                <label>–í–≤–µ–¥–∏—Ç–µ –º–∞—Ç—Ä–∏—Ü—É –≤–µ—Å–æ–≤ (—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏: –ø—Ä–æ–±–µ–ª/—Ç–∞–±—É–ª—è—Ü–∏—è, —Å—Ç—Ä–æ–∫–∏ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–≤–æ–¥ —Å—Ç—Ä–æ–∫–∏):</label>
                <textarea id="matrixInput" class="form-control" style="height: 250px; font-family: monospace;" placeholder="1 0 5 0&#10;0 2 3 4&#10;5 3 0 1&#10;0 4 1 0"></textarea>
            </div>
            <div class="form-group">
                <label>–ú–µ—Ç–∫–∏ –≤–µ—Ä—à–∏–Ω (—Ä–∞–∑–¥–µ–ª–µ–Ω—ã –∑–∞–ø—è—Ç—ã–º–∏):</label>
                <input type="text" id="vertexLabelsInput" class="form-control" placeholder="A, B, C, D">
            </div>
            <div class="form-group">
                <label>
                    <input type="checkbox" id="isDirectedMatrixInput"> –û—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥—Ä–∞—Ñ
                </label>
            </div>
            <div class="modal-buttons">
                <button class="btn" onclick="closeMatrixModal()">–û—Ç–º–µ–Ω–∞</button>
                <button class="btn primary" onclick="confirmLoadMatrix()">–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
            </div>
        </div>
    </div>


    <script>
        // ============ –ú–û–î–ï–õ–¨ –î–ê–ù–ù–´–• ============
        class Graph {
            constructor() {
                this.vertices = new Map();
                this.edges = [];
            }

            addVertex(id, label = id, x = 0, y = 0, color = '#208141', radius = 25) {
                this.vertices.set(id, { id, label, x, y, color, radius });
            }

            addEdge(from, to, weight = 1, label = '', color = '#626c7c', width = 2, isDirected = false) {
                this.edges.push({ from, to, weight, label, color, width, isDirected });
            }

            removeVertex(id) {
                this.vertices.delete(id);
                this.edges = this.edges.filter(e => e.from !== id && e.to !== id);
            }

            removeEdge(index) {
                this.edges.splice(index, 1);
            }

            clear() {
                this.vertices.clear();
                this.edges = [];
            }

            toJSON() {
                return {
                    vertices: Array.from(this.vertices.values()),
                    edges: this.edges
                };
            }

            fromJSON(data) {
                this.clear();
                data.vertices.forEach(v => {
                    this.addVertex(v.id, v.label, v.x, v.y, v.color || '#208141', v.radius || 25);
                });
                data.edges.forEach(e => {
                    this.addEdge(e.from, e.to, e.weight || 1, e.label || '', e.color || '#626c7c', e.width || 2, e.isDirected || false);
                });
            }
        }

        // ============ –°–û–°–¢–û–Ø–ù–ò–ï –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø ============
        const state = {
            graph: new Graph(),
            mode: 'select', // select, addVertex, addEdge, delete
            selectedVertex: null,
            selectedEdge: null,
            zoom: 1,
            offsetX: 0,
            offsetY: 0,
            isDragging: false,
            dragStartX: 0,
            dragStartY: 0,
            edgeFrom: null,
            highlightedPath: [],
            highlightedVertices: [],
            // –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–π –≤–µ—Ä—à–∏–Ω—ã
            pendingVertexX: 0, 
            pendingVertexY: 0,
            // –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ
            isPanning: false,
            panStartX: 0,
            panStartY: 0,
            panOffsetX: 0,
            panOffsetY: 0,
            // –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
            algoMode: 'off',       // 'off', 'bfs', 'dfs', 'dijkstra'
            algoStepMode: 'off',   // 'off', 'space', 'auto'
            algoDelay: 1000,       // –º—Å
            algoTimerId: null,

            // –¥–ª—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏
            algoCurrent: null,     // —Ç–µ–∫—É—â–∞—è –≤–µ—Ä—à–∏–Ω–∞ (–∫—Ä–∞—Å–Ω–∞—è)
            algoNext: null,        // —Å–ª–µ–¥—É—é—â–∞—è (—Ä–æ–∑–æ–≤–∞—è)

            // BFS
            bfsQueue: [],
            bfsVisited: new Set(),
            bfsOrder: [],

            // DFS
            dfsStack: [],
            dfsVisited: new Set(),
            dfsOrder: [],

            // –î–µ–π–∫—Å—Ç—Ä–∞
            djUnvisited: new Set(),
            djDistances: new Map(),
            djPrevious: new Map(),
            djOrder: [],   
            
            // –°–≤—è–∑–Ω–æ—Å—Ç—å
            componentsOriginalColors: null,
        };

        // ============ –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ============
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            render();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // ============ –†–ï–ù–î–ï–†–ò–ù–ì ============
        function render() {
            ctx.fillStyle = '#fcfcf9';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(state.zoom, state.zoom);
            ctx.translate(state.offsetX, state.offsetY);

            // –†–∏—Å—É–µ–º —Ä—ë–±—Ä–∞
            state.graph.edges.forEach((edge, index) => {
                drawEdge(edge, index);
            });

            // –†–∏—Å—É–µ–º –≤–µ—Ä—à–∏–Ω—ã
            state.graph.vertices.forEach(vertex => {
                drawVertex(vertex);
            });

            ctx.restore();
        }

        function drawVertex(vertex) {
            const isSelected = state.selectedVertex === vertex.id;
            const isHighlighted = state.highlightedVertices.includes(vertex.id);

            const isCurrentAlgo = vertex.id === state.algoCurrent; // —Ç–µ–∫—É—â–∞—è –≤–µ—Ä—à–∏–Ω–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∞
            const isNextAlgo = vertex.id === state.algoNext;       // —Å–ª–µ–¥—É—é—â–∞—è –≤ –æ—á–µ—Ä–µ–¥–∏/—Å—Ç–µ–∫–µ

            // –¶–≤–µ—Ç –ó–ê–õ–ò–í–ö–ò –≤–µ—Ä—à–∏–Ω—ã
            if (isCurrentAlgo) {
                ctx.fillStyle = '#c0152f';        // –∫—Ä–∞—Å–Ω—ã–π
            } else if (isNextAlgo) {
                ctx.fillStyle = '#f7a3a3';        // –±–ª–µ–¥–Ω–æ-—Ä–æ–∑–æ–≤—ã–π
            } else if (isHighlighted) {
                ctx.fillStyle = '#a84b2f';        // —Ç–≤–æ–π —Ü–≤–µ—Ç –¥–ª—è –ø—É—Ç–∏
            } else {
                ctx.fillStyle = vertex.color;     // –æ–±—ã—á–Ω—ã–π —Ü–≤–µ—Ç –≤–µ—Ä—à–∏–Ω—ã
            }
            ctx.beginPath();
            ctx.arc(vertex.x, vertex.y, vertex.radius, 0, Math.PI * 2);
            ctx.fill();

            if (isSelected) {
                ctx.strokeStyle = '#1f2121';
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.strokeStyle = '#208141';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }

            ctx.fillStyle = '#fcfcf9';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(vertex.label, vertex.x, vertex.y);
        }

        function drawEdge(edge, index) {
            const from = state.graph.vertices.get(edge.from);
            const to = state.graph.vertices.get(edge.to);

            if (!from || !to) return;

            const isHighlighted = state.highlightedPath.includes(index);
            const isSelected = state.selectedEdge === index;

            ctx.strokeStyle = isHighlighted ? '#c0152f' : (isSelected ? '#1f2121' : edge.color);
            ctx.lineWidth = isHighlighted ? 4 : (isSelected ? 3 : edge.width);

            // –†–∏—Å—É–µ–º –ª–∏–Ω–∏—é
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();

            // –†–∏—Å—É–µ–º —Å—Ç—Ä–µ–ª–∫—É –¥–ª—è –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ä—ë–±–µ—Ä
            if (edge.isDirected) {
                const angle = Math.atan2(to.y - from.y, to.x - from.x);
                const arrowSize = 12;
                const endX = to.x - Math.cos(angle) * (to.radius + 5);
                const endY = to.y - Math.sin(angle) * (to.radius + 5);

                ctx.fillStyle = edge.color;
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - arrowSize * Math.cos(angle - Math.PI / 6), endY - arrowSize * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(endX - arrowSize * Math.cos(angle + Math.PI / 6), endY - arrowSize * Math.sin(angle + Math.PI / 6));
                ctx.closePath();
                ctx.fill();
            }

            // –†–∏—Å—É–µ–º –º–µ—Ç–∫—É —Ä–µ–±—Ä–∞
            if (edge.label) {
                const midX = (from.x + to.x) / 2;
                const midY = (from.y + to.y) / 2;
                ctx.fillStyle = '#1f2121';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(edge.label, midX, midY - 8);
            }
        }

        // ============ –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ============

        // –ö–Ω–æ–ø–∫–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
        document.getElementById('addVertexBtn').addEventListener('click', () => {
        state.mode = state.mode === 'addVertex' ? 'select' : 'addVertex';
        document.getElementById('addVertexBtn').style.opacity = state.mode === 'addVertex' ? '0.5' : '1';
        if (state.mode === 'addVertex') {
            openAddVertexModal();
        }
    });

        document.getElementById('addEdgeBtn').addEventListener('click', () => {
            state.mode = state.mode === 'addEdge' ? 'select' : 'addEdge';
            document.getElementById('addEdgeBtn').style.opacity = state.mode === 'addEdge' ? '0.5' : '1';
            state.edgeFrom = null;
        });

        document.getElementById('deleteBtn').addEventListener('click', () => {
            if (state.selectedVertex) {
                state.graph.removeVertex(state.selectedVertex);
                state.selectedVertex = null;
            } else if (state.selectedEdge !== null) {
                state.graph.removeEdge(state.selectedEdge);
                state.selectedEdge = null;
            }
            updateStatus();
            render();
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            if (confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –æ—Ç–º–µ–Ω–∏—Ç—å.')) {
                state.graph.clear();
                state.selectedVertex = null;
                state.selectedEdge = null;
                state.highlightedPath = [];
                state.highlightedVertices = [];
                updateStatus();
                render();
            }
        });

        // –ú–∞–∫–µ—Ç—ã
        document.getElementById('forceLayoutBtn').addEventListener('click', () => {
            forceDirectedLayout();
            render();
        });

        document.getElementById('circleLayoutBtn').addEventListener('click', () => {
            circleLayout();
            render();
        });

        document.getElementById('gridLayoutBtn').addEventListener('click', () => {
            gridLayout();
            render();
        });

        document.getElementById('treeLayoutBtn').addEventListener('click', openTreeLayoutModal);


        // –ê–ª–≥–æ—Ä–∏—Ç–º—ã
        document.getElementById('dijkstraBtn').addEventListener('click', openDijkstraModal);
        document.getElementById('bfsBtn').addEventListener('click', openBfsModal);
        document.getElementById('dfsBtn').addEventListener('click', openDfsModal);
        document.getElementById('componentsBtn').addEventListener('click', findConnectedComponents);
        document.getElementById('cutVertexBtn').addEventListener('click', findCutVertices);
        document.getElementById('bridgeBtn').addEventListener('click', findBridges);

        // –ú–∞—Ç—Ä–∏—Ü—ã
        document.getElementById('loadMatrixBtn').addEventListener('click', loadGraphFromMatrix);
        document.getElementById('saveMatrixBtn').addEventListener('click', saveGraphAsMatrix);


        // –§–∞–π–ª—ã
        document.getElementById('saveBtn').addEventListener('click', saveGraph);
        document.getElementById('loadBtn').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });
        document.getElementById('exportBtn').addEventListener('click', exportCanvas);

        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        state.graph.fromJSON(data);
                        state.selectedVertex = null;
                        state.selectedEdge = null;
                        updateStatus();
                        render();
                    } catch (error) {
                        alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
        });

        // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            state.zoom *= 1.2;
            updateZoomDisplay();
            render();
        });

        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            state.zoom /= 1.2;
            updateZoomDisplay();
            render();
        });

        document.getElementById('resetZoomBtn').addEventListener('click', () => {
            state.zoom = 1;
            state.offsetX = 0;
            state.offsetY = 0;
            updateZoomDisplay();
            render();
        });


        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫ –≤ –º–æ–¥–∞–ª—å–Ω—ã—Ö –æ–∫–Ω–∞—Ö
        document.getElementById('vertexLabelInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                confirmAddVertex();
            }
        });

        // Canvas —Å–æ–±—ã—Ç–∏—è
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = (e.clientX - rect.left - canvas.width / 2) / state.zoom - state.offsetX;
            const canvasY = (e.clientY - rect.top - canvas.height / 2) / state.zoom - state.offsetY;

            document.getElementById('mousePos').textContent = `–ü–æ–∑–∏—Ü–∏—è: ${Math.round(canvasX)}, ${Math.round(canvasY)}`;

            if (state.isDragging && state.selectedVertex) {
                const vertex = state.graph.vertices.get(state.selectedVertex);
                vertex.x = canvasX;
                vertex.y = canvasY;
                render();
            }
            else if (state.isPanning) {
                const dx = (e.clientX - state.panStartX) / state.zoom;
                const dy = (e.clientY - state.panStartY) / state.zoom;
                state.offsetX = state.panOffsetX + dx;
                state.offsetY = state.panOffsetY + dy;
                render();
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = (e.clientX - rect.left - canvas.width / 2) / state.zoom - state.offsetX;
            const canvasY = (e.clientY - rect.top - canvas.height / 2) / state.zoom - state.offsetY;

            if (e.button === 2) return; // Right click handled separately

            // –ü–æ–∏—Å–∫ –≤–µ—Ä—à–∏–Ω—ã –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
            let clickedVertex = null;
            for (let [id, vertex] of state.graph.vertices) {
                const dist = Math.hypot(vertex.x - canvasX, vertex.y - canvasY);
                if (dist <= vertex.radius) {
                    clickedVertex = id;
                    break;
                }
            }

            if (state.mode === 'addVertex' && !clickedVertex) {
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
                state.pendingVertexX = canvasX;
                state.pendingVertexY = canvasY;
                openAddVertexModal();
            } else if (state.mode === 'addEdge') {
                if (!state.edgeFrom && clickedVertex) {
                    // –≤—ã–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ä—Ç–æ–≤—É—é –≤–µ—Ä—à–∏–Ω—É –¥–ª—è —Ä–µ–±—Ä–∞
                    state.edgeFrom = clickedVertex;
                } else if (state.edgeFrom && clickedVertex 
                            && clickedVertex !== state.edgeFrom) {
                    state.graph.addEdge(state.edgeFrom, clickedVertex, 1, '', '#626c7c', 2, false);
                    state.edgeFrom = null;
                    state.mode = 'select';
                    document.getElementById('addEdgeBtn').style.opacity = '1';
                    updateStatus();
                    render();
                }
            } else if (state.mode === 'select') {
                state.selectedEdge = null;

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª–∏–∫–∞ –ø–æ —Ä—ë–±—Ä–∞–º
                for (let i = 0; i < state.graph.edges.length; i++) {
                    const edge = state.graph.edges[i];
                    const from = state.graph.vertices.get(edge.from);
                    const to = state.graph.vertices.get(edge.to);
                    const dist = pointToLineDistance(canvasX, canvasY, from.x, from.y, to.x, to.y);
                    if (dist < 10) {
                        state.selectedEdge = i;
                        break;
                    }
                }

                if (clickedVertex) {
                    state.selectedVertex = clickedVertex;
                    state.isDragging = true;
                } else {
                    // –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Ö–æ–ª—Å—Ç–∞
                    state.selectedVertex = null;
                    state.isDragging = false;
                    state.isPanning = true;
                    state.panStartX = e.clientX;
                    state.panStartY = e.clientY;
                    state.panOffsetX = state.offsetX;
                    state.panOffsetY = state.offsetY;
                }

                updatePropertiesPanel();
                render();
            }
        });

        canvas.addEventListener('mouseup', () => {
            state.isDragging = false;
            state.isPanning = false;
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const canvasX = (e.clientX - rect.left - canvas.width / 2) / state.zoom - state.offsetX;
            const canvasY = (e.clientY - rect.top - canvas.height / 2) / state.zoom - state.offsetY;

            for (let [id, vertex] of state.graph.vertices) {
                const dist = Math.hypot(vertex.x - canvasX, vertex.y - canvasY);
                if (dist <= vertex.radius) {
                    state.graph.removeVertex(id);
                    state.selectedVertex = null;
                    state.selectedEdge = null;
                    updateStatus();
                    render();
                    return;
                }
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            state.zoom *= zoomFactor;
            state.zoom = Math.max(0.1, Math.min(state.zoom, 5));
            updateZoomDisplay();
            render();
        });

        // –°–≤–æ–π—Å—Ç–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        document.getElementById('vertexLabel').addEventListener('change', (e) => {
            if (state.selectedVertex) {
                state.graph.vertices.get(state.selectedVertex).label = e.target.value;
                render();
            }
        });

        document.getElementById('vertexColor').addEventListener('change', (e) => {
            if (state.selectedVertex) {
                state.graph.vertices.get(state.selectedVertex).color = e.target.value;
                render();
            }
        });

        document.getElementById('vertexRadius').addEventListener('change', (e) => {
            if (state.selectedVertex) {
                state.graph.vertices.get(state.selectedVertex).radius = parseInt(e.target.value);
                render();
            }
        });

        document.getElementById('edgeLabel').addEventListener('change', (e) => {
            if (state.selectedEdge !== null) {
                state.graph.edges[state.selectedEdge].label = e.target.value;
                render();
            }
        });

        document.getElementById('edgeWeight').addEventListener('change', (e) => {
            if (state.selectedEdge !== null) {
                state.graph.edges[state.selectedEdge].weight = parseFloat(e.target.value);
            }
        });

        document.getElementById('edgeColor').addEventListener('change', (e) => {
            if (state.selectedEdge !== null) {
                state.graph.edges[state.selectedEdge].color = e.target.value;
                render();
            }
        });

        document.getElementById('edgeWidth').addEventListener('change', (e) => {
            if (state.selectedEdge !== null) {
                state.graph.edges[state.selectedEdge].width = parseInt(e.target.value);
                render();
            }
        });

        document.getElementById('isDirected').addEventListener('change', (e) => {
            if (state.selectedEdge !== null) {
                state.graph.edges[state.selectedEdge].isDirected = e.target.checked;
                render();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && state.algoStepMode === 'space') {
                e.preventDefault();
                if (state.algoMode === 'bfs') bfsStep();
                else if (state.algoMode === 'dfs') dfsStep();
                else if (state.algoMode === 'dijkstra') dijkstraStep();
            }
            if (e.key === 'Shift') {
                e.preventDefault();

                // 1) –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Å–≤—è–∑–Ω–æ—Å—Ç–∏: –≤–µ—Ä–Ω—É—Ç—å –∏—Å—Ö–æ–¥–Ω—ã–µ —Ü–≤–µ—Ç–∞ –≤–µ—Ä—à–∏–Ω
                if (state.componentsOriginalColors) {
                    state.componentsOriginalColors.forEach((color, id) => {
                        const v = state.graph.vertices.get(id);
                        if (v) v.color = color;
                    });
                    state.componentsOriginalColors = null;
                }

                // 2) –®–∞—Ä–Ω–∏—Ä—ã / –¥—Ä—É–≥–∏–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –ø–µ—Ä–µ–∫—Ä–∞—Å–∫–∏ –≤–µ—Ä—à–∏–Ω
                if (state._originalVertexColors) {
                    state._originalVertexColors.forEach((color, id) => {
                        const v = state.graph.vertices.get(id);
                        if (v) v.color = color;
                    });
                    state._originalVertexColors = null;
                }

                // 3) –°–±—Ä–æ—Å–∏—Ç—å –ø–æ–¥—Å–≤–µ—Ç–∫—É –ø—É—Ç–µ–π / —Ä—ë–±–µ—Ä, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                state.highlightedVertices = [];
                state.highlightedPath = [];
                state.algoCurrent = null;
                state.algoNext = null;

                render();
            }
        });

        // ============ –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ============

        function updatePropertiesPanel() {
            const noSelection = document.getElementById('noSelection');
            const vertexProps = document.getElementById('vertexProperties');
            const edgeProps = document.getElementById('edgeProperties');

            noSelection.classList.remove('hidden');
            vertexProps.classList.add('hidden');
            edgeProps.classList.add('hidden');

            if (state.selectedVertex) {
                const vertex = state.graph.vertices.get(state.selectedVertex);
                document.getElementById('vertexLabel').value = vertex.label;
                document.getElementById('vertexColor').value = vertex.color;
                document.getElementById('vertexRadius').value = vertex.radius;

                noSelection.classList.add('hidden');
                vertexProps.classList.remove('hidden');
            } else if (state.selectedEdge !== null) {
                const edge = state.graph.edges[state.selectedEdge];
                document.getElementById('edgeLabel').value = edge.label;
                document.getElementById('edgeWeight').value = edge.weight;
                document.getElementById('edgeColor').value = edge.color;
                document.getElementById('edgeWidth').value = edge.width;
                document.getElementById('isDirected').checked = edge.isDirected;

                noSelection.classList.add('hidden');
                edgeProps.classList.remove('hidden');
            }
        }

        function updateStatus() {
            document.getElementById('vertexCount').textContent = `–í–µ—Ä—à–∏–Ω: ${state.graph.vertices.size}`;
            document.getElementById('edgeCount').textContent = `–†—ë–±–µ—Ä: ${state.graph.edges.length}`;
        }

        function updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = `${Math.round(state.zoom * 100)}%`;
        }

        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;
            let xx, yy;
            if (param < 0) { xx = x1; yy = y1; }
            else if (param > 1) { xx = x2; yy = y2; }
            else { xx = x1 + param * C; yy = y1 + param * D; }
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // ============ –î–û–ë–ê–í–õ–ï–ù–ò–ï –í–ï–†–®–ò–ù–´ ============


        function openAddVertexModal() {
            const input = document.getElementById('vertexLabelInput');
            input.value = '';
            input.focus();
            document.getElementById('addVertexModal').classList.add('active');
        }

        function closeAddVertexModal() {
            document.getElementById('addVertexModal').classList.remove('active');
            state.mode = 'select';
            document.getElementById('addVertexBtn').style.opacity = '1';
        }

        function confirmAddVertex() {
            const label = document.getElementById('vertexLabelInput').value.trim();

            if (label === '') {
                alert('–ú–µ—Ç–∫–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç–æ–π!');
                return;
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ –º–µ—Ç–∫–∏
            for (let [id, vertex] of state.graph.vertices) {
                if (vertex.label === label) {
                    alert('–í–µ—Ä—à–∏–Ω–∞ —Å —Ç–∞–∫–æ–π –º–µ—Ç–∫–æ–π —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!');
                    return;
                }
            }

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–Ω–∏–∫–∞–ª—å–Ω–æ–≥–æ ID
            let id = label;
            let counter = 1;
            while (state.graph.vertices.has(id)) {
                id = label + counter;
                counter++;
            }

            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤–µ—Ä—à–∏–Ω—ã —Å —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–º–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
            const x = state.pendingVertexX || 0;
            const y = state.pendingVertexY || 0;
            state.graph.addVertex(id, label, x, y);
            state.selectedVertex = id;


            if ((state.pendingVertexX > 150 && state.pendingVertexY < -150)
                || (state.pendingVertexX < -150 && state.pendingVertexY > 150)
            ){
                state.pendingVertexX -= 20;
                state.pendingVertexY += 20;
            }
            else{
                state.pendingVertexX += 20;
                state.pendingVertexY -= 20;
            }
            

            updateStatus();
            render();
            updatePropertiesPanel();
            closeAddVertexModal();
        }


        // ============ –ú–ê–ö–ï–¢–´ ============

        function forceDirectedLayout() {
            const iterations = 100;
            const k = 100;
            const c = 0.1;

            for (let iter = 0; iter < iterations; iter++) {
                const forces = new Map();
                for (let [id] of state.graph.vertices) {
                    forces.set(id, { x: 0, y: 0 });
                }

                // –û—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏–µ –º–µ–∂–¥—É –≤–µ—Ä—à–∏–Ω–∞–º–∏
                const vertices = Array.from(state.graph.vertices.values());
                for (let i = 0; i < vertices.length; i++) {
                    for (let j = i + 1; j < vertices.length; j++) {
                        const v1 = vertices[i];
                        const v2 = vertices[j];
                        const dx = v2.x - v1.x;
                        const dy = v2.y - v1.y;
                        const dist = Math.hypot(dx, dy) + 0.1;
                        const force = (k * k) / dist;
                        forces.get(v1.id).x -= (force * dx) / dist;
                        forces.get(v1.id).y -= (force * dy) / dist;
                        forces.get(v2.id).x += (force * dx) / dist;
                        forces.get(v2.id).y += (force * dy) / dist;
                    }
                }

                // –ü—Ä–∏—Ç—è–∂–µ–Ω–∏–µ –≤–¥–æ–ª—å —Ä—ë–±–µ—Ä
                for (let edge of state.graph.edges) {
                    const v1 = state.graph.vertices.get(edge.from);
                    const v2 = state.graph.vertices.get(edge.to);
                    const dx = v2.x - v1.x;
                    const dy = v2.y - v1.y;
                    const dist = Math.hypot(dx, dy) + 0.1;
                    const force = (dist * dist) / k;
                    forces.get(v1.id).x += (force * dx) / dist;
                    forces.get(v1.id).y += (force * dy) / dist;
                    forces.get(v2.id).x -= (force * dx) / dist;
                    forces.get(v2.id).y -= (force * dy) / dist;
                }

                // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–∏–ª—ã
                for (let [id, vertex] of state.graph.vertices) {
                    const f = forces.get(id);
                    const dist = Math.hypot(f.x, f.y);
                    if (dist > 0) {
                        vertex.x += c * (f.x / dist) * Math.min(dist, 50);
                        vertex.y += c * (f.y / dist) * Math.min(dist, 50);
                    }
                }
            }
        }

        function circleLayout() {
            const vertices = Array.from(state.graph.vertices.values());
            const radius = Math.max(200, vertices.length * 30);
            const center = { x: 0, y: 0 };

            vertices.forEach((vertex, i) => {
                const angle = (i / vertices.length) * Math.PI * 2;
                vertex.x = center.x + Math.cos(angle) * radius;
                vertex.y = center.y + Math.sin(angle) * radius;
            });
        }

        function gridLayout() {
            const vertices = Array.from(state.graph.vertices.values());
            const cols = Math.ceil(Math.sqrt(vertices.length));
            const spacing = 150;

            vertices.forEach((vertex, i) => {
                vertex.x = (i % cols - cols / 2) * spacing;
                vertex.y = (Math.floor(i / cols) - cols / 2) * spacing;
            });
        }

        function openTreeLayoutModal() {
            if (state.graph.vertices.size === 0) {
                alert('–ì—Ä–∞—Ñ –ø—É—Å—Ç');
                return;
            }

            const select = document.getElementById('treeRootVertex');
            select.innerHTML = '';

            for (let [id, v] of state.graph.vertices) {
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = v.label || id;
                select.appendChild(opt);
            }

            document.getElementById('treeModal').classList.add('active');
        }

        function closeTreeModal() {
            document.getElementById('treeModal').classList.remove('active');
        }

        function applyTreeLayout() {
            const rootId = document.getElementById('treeRootVertex').value;
            closeTreeModal();  // —Å—Ä–∞–∑—É —Å–∫—Ä—ã–≤–∞–µ–º –º–æ–¥–∞–ª–∫—É

            if (!state.graph.vertices.has(rootId)) return;

            // 1. –°—Ç—Ä–æ–∏–º —É—Ä–æ–≤–Ω–∏ (BFS –ø–æ –Ω–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º—É –≥—Ä–∞—Ñ—É)
            const levels = [];                      // levels[depth] = [vertexIds]
            const levelMap = new Map();            // id -> depth
            const visited = new Set();
            const queue = [rootId];

            visited.add(rootId);
            levelMap.set(rootId, 0);

            while (queue.length > 0) {
                const current = queue.shift();
                const depth = levelMap.get(current);

                if (!levels[depth]) levels[depth] = [];
                levels[depth].push(current);

                for (const edge of state.graph.edges) {
                    let neighbor = null;
                    if (edge.from === current) neighbor = edge.to;
                    else if (!edge.isDirected && edge.to === current) neighbor = edge.from;

                    if (neighbor !== null && !visited.has(neighbor)) {
                        visited.add(neighbor);
                        levelMap.set(neighbor, depth + 1);
                        queue.push(neighbor);
                    }
                }
            }

            // 2. –†–∞—Å–∫–ª–∞–¥—ã–≤–∞–µ–º –ø–æ —É—Ä–æ–≤–Ω—é: –∫–æ—Ä–µ–Ω—å —Å–≤–µ—Ä—Ö—É, –¥–µ—Ç–∏ –Ω–∏–∂–µ
            const levelHeight = 150; // –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —à–∞–≥ –º–µ–∂–¥—É —É—Ä–æ–≤–Ω—è–º–∏
            const nodeSpacing = 120; // –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π —à–∞–≥ –º–µ–∂–¥—É –≤–µ—Ä—à–∏–Ω–∞–º–∏

            levels.forEach((level, depth) => {
                const y = depth * levelHeight;

                const totalWidth = (level.length - 1) * nodeSpacing;
                let x = -totalWidth / 2;

                level.forEach(id => {
                    const v = state.graph.vertices.get(id);
                    if (v) {
                        v.x = x;
                        v.y = y;
                    }
                    x += nodeSpacing;
                });
            });

            // 3. –î–ª—è –≤–µ—Ä—à–∏–Ω, –Ω–µ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç—ã—Ö –æ—Ç –∫–æ—Ä–Ω—è (–µ—Å–ª–∏ –≥—Ä–∞—Ñ –Ω–µ—Å–≤—è–∑–Ω—ã–π),
            // –ø—Ä–æ—Å—Ç–æ —Ä–∞–∑–ª–æ–∂–∏–º –∏—Ö –ø–æ–¥ –ø–æ—Å–ª–µ–¥–Ω–∏–º —É—Ä–æ–≤–Ω–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–º —Å–ª–æ–µ–º
            const notPlaced = [];
            for (let [id] of state.graph.vertices) {
                if (!visited.has(id)) notPlaced.push(id);
            }

            if (notPlaced.length > 0) {
                const depth = levels.length; // —Å–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å
                const y = depth * levelHeight;
                const totalWidth = (notPlaced.length - 1) * nodeSpacing;
                let x = -totalWidth / 2;

                notPlaced.forEach(id => {
                    const v = state.graph.vertices.get(id);
                    if (v) {
                        v.x = x;
                        v.y = y;
                    }
                    x += nodeSpacing;
                });
            }

            render();
        }


        // ============ –ê–õ–ì–û–†–ò–¢–ú–´ ============

        // –î–µ–π–∫—Å—Ç—Ä–∞ (–∫—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å)
        function openDijkstraModal() {
            if (state.graph.vertices.size < 2) {
                alert('–ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 2 –≤–µ—Ä—à–∏–Ω—ã');
                return;
            }

            const select1 = document.getElementById('startVertex');
            const select2 = document.getElementById('endVertex');
            select1.innerHTML = '';
            select2.innerHTML = '';

            for (let [id, vertex] of state.graph.vertices) {
                const opt1 = document.createElement('option');
                opt1.value = id;
                opt1.textContent = vertex.label || id;
                select1.appendChild(opt1);

                const opt2 = document.createElement('option');
                opt2.value = id;
                opt2.textContent = vertex.label || id;
                select2.appendChild(opt2);
            }

            document.getElementById('dijkstraModal').classList.add('active');
        }

        function closeDijkstraModal() {
            document.getElementById('dijkstraModal').classList.remove('active');
        }

        /*function runDijkstra() {
            const start = document.getElementById('startVertex').value;
            const end = document.getElementById('endVertex').value;

            const distances = new Map();
            const previous = new Map();
            const unvisited = new Set();

            for (let [id] of state.graph.vertices) {
                distances.set(id, id === start ? 0 : Infinity);
                previous.set(id, null);
                unvisited.add(id);
            }

            while (unvisited.size > 0) {
                let current = null;
                let minDist = Infinity;

                for (let id of unvisited) {
                    if (distances.get(id) < minDist) {
                        minDist = distances.get(id);
                        current = id;
                    }
                }

                if (current === null || distances.get(current) === Infinity) break;

                unvisited.delete(current);

                for (let edge of state.graph.edges) {
                    if (edge.from === current && unvisited.has(edge.to)) {
                        const alt = distances.get(current) + edge.weight;
                        if (alt < distances.get(edge.to)) {
                            distances.set(edge.to, alt);
                            previous.set(edge.to, current);
                        }
                    }
                }
            }

            // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É—Ç–∏
            const path = [];
            let current = end;
            while (current !== null) {
                path.unshift(current);
                current = previous.get(current);
            }

            if (path[0] !== start) {
                alert('–ü—É—Ç–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç');
                closeDijkstraModal();
                return;
            }

            state.highlightedVertices = path;
            state.highlightedPath = [];

            for (let i = 0; i < path.length - 1; i++) {
                for (let j = 0; j < state.graph.edges.length; j++) {
                    const edge = state.graph.edges[j];
                    if ((edge.from === path[i] && edge.to === path[i + 1]) ||
                        (!edge.isDirected && edge.from === path[i + 1] && edge.to === path[i])) {
                        state.highlightedPath.push(j);
                        break;
                    }
                }
            }

            alert(`–ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å –Ω–∞–π–¥–µ–Ω!\n–î–∏—Å—Ç–∞–Ω—Ü–∏—è: ${distances.get(end)}\n–ü—É—Ç—å: ${path.join(' ‚Üí ')}`);
            closeDijkstraModal();
            render();
        }*/

        function startDijkstraVisualization() {
            closeDijkstraModal();
            
            const start = document.getElementById('startVertex').value;
            const end = document.getElementById('endVertex').value;
            const mode = document.getElementById('djModeSelect').value;
            const delaySec = parseFloat(document.getElementById('djDelayInput').value) || 1;

            if (state.algoTimerId) {
                clearInterval(state.algoTimerId);
                state.algoTimerId = null;
            }

            state.algoMode = 'dijkstra';
            state.algoStepMode = mode;
            state.algoDelay = delaySec * 1000;

            state.djDistances = new Map();
            state.djPrevious = new Map();
            state.djUnvisited = new Set();
            state.djOrder = [];

            for (let [id] of state.graph.vertices) {
                state.djDistances.set(id, id === start ? 0 : Infinity);
                state.djPrevious.set(id, null);
                state.djUnvisited.add(id);
            }

            state.dijkstraStart = start;
            state.dijkstraEnd = end;

            state.algoCurrent = null;
            state.algoNext = start;

            //closeDijkstraModal();
            render();

            if (mode === 'auto') {
                state.algoTimerId = setInterval(dijkstraStep, state.algoDelay);
            }
        }

        function dijkstraStep() {
            if (state.djUnvisited.size === 0) {
                finishDijkstra();
                return;
            }

            // –≤—ã–±–∏—Ä–∞–µ–º –≤–µ—Ä—à–∏–Ω—É —Å –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –¥–∏—Å—Ç–∞–Ω—Ü–∏–µ–π —Å—Ä–µ–¥–∏ –Ω–µ–ø–æ—Å–µ—â—ë–Ω–Ω—ã—Ö
            let current = null;
            let minDist = Infinity;
            for (let id of state.djUnvisited) {
                const d = state.djDistances.get(id);
                if (d < minDist) {
                    minDist = d;
                    current = id;
                }
            }

            if (current === null || minDist === Infinity) {
                // –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –Ω–µ–¥–æ—Å—Ç–∏–∂–∏–º—ã
                finishDijkstra();
                return;
            }

            state.djUnvisited.delete(current);
            state.djOrder.push(current);
            state.algoCurrent = current;

            // —Ä–µ–ª–∞–∫—Å–∏—Ä—É–µ–º —Å–æ—Å–µ–¥–µ–π
            for (let edge of state.graph.edges) {
                let neighbor = null;
                if (edge.from === current && state.djUnvisited.has(edge.to)) {
                    neighbor = edge.to;
                } else if (!edge.isDirected && edge.to === current && state.djUnvisited.has(edge.from)) {
                    neighbor = edge.from;
                }

                if (neighbor !== null) {
                    const alt = state.djDistances.get(current) + edge.weight;
                    if (alt < state.djDistances.get(neighbor)) {
                        state.djDistances.set(neighbor, alt);
                        state.djPrevious.set(neighbor, current);
                    }
                }
            }

            // —Å–ª–µ–¥—É—é—â–∞—è –≤–µ—Ä—à–∏–Ω–∞ –≤ –æ—á–µ—Ä–µ–¥–∏ (–ø–æ —Ç–µ–∫—É—â–∏–º –¥–∏—Å—Ç–∞–Ω—Ü–∏—è–º)
            let next = null;
            let nextMin = Infinity;
            for (let id of state.djUnvisited) {
                const d = state.djDistances.get(id);
                if (d < nextMin) {
                    nextMin = d;
                    next = id;
                }
            }
            state.algoNext = next;

            // –µ—Å–ª–∏ —Ç–µ–∫—É—â–∞—è ‚Äî —ç—Ç–æ —Ü–µ–ª–µ–≤–∞—è, –º–æ–∂–Ω–æ –∑–∞–≤–µ—Ä—à–∏—Ç—å –∑–∞—Ä–∞–Ω–µ–µ
            if (current === state.dijkstraEnd) {
                finishDijkstra();
                return;
            }

            render();
        }

        function finishDijkstra() {
            if (state.algoTimerId) {
                clearInterval(state.algoTimerId);
                state.algoTimerId = null;
            }

            const start = state.dijkstraStart;
            const end = state.dijkstraEnd;

            // –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É—Ç–∏
            const path = [];
            let cur = end;
            while (cur !== null) {
                path.unshift(cur);
                cur = state.djPrevious.get(cur);
            }

            if (path[0] !== start) {
                alert('–ü—É—Ç–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç');
            } else {
                const dist = state.djDistances.get(end);
                const labels = path.map(id => state.graph.vertices.get(id).label || id);
                alert(`–ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å –Ω–∞–π–¥–µ–Ω!\n–î–∏—Å—Ç–∞–Ω—Ü–∏—è: ${dist}\n–ü—É—Ç—å: ${labels.join(' ‚Üí ')}`);
            }

            state.algoCurrent = null;
            state.algoNext = null;
            state.algoMode = 'off';
            state.algoStepMode = 'off';
            render();
        }

        // –û–±—Ö–æ–¥ –≤ —à–∏—Ä–∏–Ω—É
        function openBfsModal() {
            if (state.graph.vertices.size < 1) {
                alert('–ì—Ä–∞—Ñ –ø—É—Å—Ç');
                return;
            }

            const select = document.getElementById('bfsStartVertex');
            select.innerHTML = '';

            for (let [id, vertex] of state.graph.vertices) {
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = vertex.label || id;
                select.appendChild(opt);
            }

            document.getElementById('bfsModal').classList.add('active');
        }

        function closeBfsModal() {
            document.getElementById('bfsModal').classList.remove('active');
        }

        /*function runBFS() {
            const start = document.getElementById('bfsStartVertex').value;
            const visited = new Set();
            const queue = [start];
            const order = [];

            while (queue.length > 0) {
                const current = queue.shift();
                if (visited.has(current)) continue;
                visited.add(current);
                order.push(current);

                for (let edge of state.graph.edges) {
                    if (edge.from === current && !visited.has(edge.to)) {
                        queue.push(edge.to);
                    } else if (!edge.isDirected && edge.to === current && !visited.has(edge.from)) {
                        queue.push(edge.from);
                    }
                }
            }

            state.highlightedVertices = order;
            state.highlightedPath = [];
            const pathStr = order.map(id => state.graph.vertices.get(id).label || id).join(' ‚Üí ');
            alert('BFS –æ–±—Ö–æ–¥: ' + pathStr);
            closeBfsModal();
            render();
        }*/

        function startBfsVisualization() {
            closeBfsModal();
            
            const start = document.getElementById('bfsStartVertex').value;
            const mode = document.getElementById('bfsModeSelect').value;
            const delaySec = parseFloat(document.getElementById('bfsDelayInput').value) || 1;

            if (state.algoTimerId) {
                clearInterval(state.algoTimerId);
                state.algoTimerId = null;
            }

            state.algoMode = 'bfs';
            state.algoStepMode = mode;
            state.algoDelay = delaySec * 1000;

            state.bfsVisited = new Set();
            state.bfsOrder = [];
            state.bfsQueue = [start];

            state.algoCurrent = null;
            state.algoNext = start;

            //closeBfsModal();
            render();

            if (mode === 'auto') {
                state.algoTimerId = setInterval(bfsStep, state.bfsDelay);
            }
            // –í —Ä–µ–∂–∏–º–µ –ø–æ –ø—Ä–æ–±–µ–ª—É —à–∞–≥–∏ –ø–æ–π–¥—É—Ç –∏–∑ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
        }

        function bfsStep() {
            if (state.bfsQueue.length === 0) {
                // –û–±—Ö–æ–¥ –∑–∞–∫–æ–Ω—á–µ–Ω
                if (state.algoTimerId) {
                    clearInterval(state.algoTimerId);
                    state.algoTimerId = null;
                }
                state.algoCurrent = null;
                state.algoNext = null;
                render();

                const labels = state.bfsOrder.map(id => state.graph.vertices.get(id).label || id);
                alert('BFS –ø–æ—Ä—è–¥–æ–∫: ' + labels.join(' ‚Üí '));

                state.algoMode = 'off';
                state.algoStepMode = 'off';
                return;
            }

            const current = state.bfsQueue.shift();
            state.algoCurrent = current;
            state.bfsVisited.add(current);
            state.bfsOrder.push(current);

            // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ—Å–µ–¥–µ–π
            for (let edge of state.graph.edges) {
                if (edge.from === current && !state.bfsVisited.has(edge.to) && !state.bfsQueue.includes(edge.to)) {
                    state.bfsQueue.push(edge.to);
                } else if (!edge.isDirected && edge.to === current &&
                        !state.bfsVisited.has(edge.from) && !state.bfsQueue.includes(edge.from)) {
                    state.bfsQueue.push(edge.from);
                }
            }

            // –°–ª–µ–¥—É—é—â–∞—è –≤–µ—Ä—à–∏–Ω–∞ –≤ –æ—á–µ—Ä–µ–¥–∏ (–¥–ª—è –±–ª–µ–¥–Ω–æ-—Ä–æ–∑–æ–≤–æ–≥–æ)
            state.algoNext = state.bfsQueue.length > 0 ? state.bfsQueue[0] : null;

            render();
        }

        // –û–±—Ö–æ–¥ –≤ –≥–ª—É–±–∏–Ω—É
        function openDfsModal() {
            if (state.graph.vertices.size < 1) {
                alert('–ì—Ä–∞—Ñ –ø—É—Å—Ç');
                return;
            }

            const select = document.getElementById('dfsStartVertex');
            select.innerHTML = '';

            for (let [id, vertex] of state.graph.vertices) {
                const opt = document.createElement('option');
                opt.value = id;
                opt.textContent = vertex.label || id;
                select.appendChild(opt);
            }

            document.getElementById('dfsModal').classList.add('active');
        }

        function closeDfsModal() {
            document.getElementById('dfsModal').classList.remove('active');
        }

        /*function runDFS() {
            const start = document.getElementById('dfsStartVertex').value;
            const visited = new Set();
            const order = [];

            function dfs(vertex) {
                visited.add(vertex);
                order.push(vertex);

                for (let edge of state.graph.edges) {
                    if (edge.from === vertex && !visited.has(edge.to)) {
                        dfs(edge.to);
                    } else if (!edge.isDirected && edge.to === vertex && !visited.has(edge.from)) {
                        dfs(edge.from);
                    }
                }
            }

            dfs(start);

            state.highlightedVertices = order;
            state.highlightedPath = [];
            const pathStr = order.map(id => state.graph.vertices.get(id).label || id).join(' ‚Üí ');
            alert('DFS –æ–±—Ö–æ–¥: ' + pathStr);
            closeDfsModal();
            render();
        }*/

        function startDfsVisualization() {
            closeDfsModal();

            const start = document.getElementById('dfsStartVertex').value;
            const mode = document.getElementById('dfsModeSelect').value;
            const delaySec = parseFloat(document.getElementById('dfsDelayInput').value) || 1;

            if (state.algoTimerId) {
                clearInterval(state.algoTimerId);
                state.algoTimerId = null;
            }

            state.algoMode = 'dfs';
            state.algoStepMode = mode;
            state.algoDelay = delaySec * 1000;

            state.dfsVisited = new Set();
            state.dfsOrder = [];
            state.dfsStack = [start];

            state.algoCurrent = null;
            state.algoNext = start;

            //closeDfsModal();
            render();

            if (mode === 'auto') {
                state.algoTimerId = setInterval(dfsStep, state.algoDelay);
            }
        }

        function dfsStep() {
            if (state.dfsStack.length === 0) {
                // –∑–∞–∫–æ–Ω—á–µ–Ω–æ
                if (state.algoTimerId) {
                    clearInterval(state.algoTimerId);
                    state.algoTimerId = null;
                }
                state.algoCurrent = null;
                state.algoNext = null;
                render();

                const labels = state.dfsOrder.map(id => state.graph.vertices.get(id).label || id);
                alert('DFS –ø–æ—Ä—è–¥–æ–∫: ' + labels.join(' ‚Üí '));

                state.algoMode = 'off';
                state.algoStepMode = 'off';
                return;
            }

            const current = state.dfsStack.pop();
            if (state.dfsVisited.has(current)) {
                // –∏—â–µ–º —Å–ª–µ–¥—É—é—â–µ–≥–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞
                state.algoCurrent = current;
                state.algoNext = state.dfsStack.length ? state.dfsStack[state.dfsStack.length - 1] : null;
                render();
                return;
            }

            state.dfsVisited.add(current);
            state.dfsOrder.push(current);
            state.algoCurrent = current;

            // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ—Å–µ–¥–µ–π –≤ —Å—Ç–µ–∫ (—á—Ç–æ–±—ã –ø–æ—Ä—è–¥–æ–∫ –±—ã–ª ¬´–µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–º¬ª, –º–æ–∂–Ω–æ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å)
            const neighbors = [];
            for (let edge of state.graph.edges) {
                if (edge.from === current) {
                    neighbors.push(edge.to);
                } else if (!edge.isDirected && edge.to === current) {
                    neighbors.push(edge.from);
                }
            }
            // –¥–æ–±–∞–≤–ª—è–µ–º –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ, —á—Ç–æ–±—ã –ø–µ—Ä–≤—ã–π –≤ —Å–ø–∏—Å–∫–µ –±—ã–ª –æ–±—Ä–∞–±–æ—Ç–∞–Ω —Ä–∞–Ω—å—à–µ
            neighbors.reverse().forEach(n => {
                if (!state.dfsVisited.has(n) && !state.dfsStack.includes(n)) {
                    state.dfsStack.push(n);
                }
            });

            state.algoNext = state.dfsStack.length ? state.dfsStack[state.dfsStack.length - 1] : null;

            render();
        }

        // –°–≤—è–∑–Ω–æ—Å—Ç—å
        function findConnectedComponents() {
            const vertices = Array.from(state.graph.vertices.keys());
            if (vertices.length === 0) {
                alert('–ì—Ä–∞—Ñ –ø—É—Å—Ç');
                return;
            }

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ —Ü–≤–µ—Ç–∞, –µ—Å–ª–∏ –µ—â—ë –Ω–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã
            const originalColors = new Map();
            state.graph.vertices.forEach((v, id) => {
                originalColors.set(id, v.color);
            });
            state.componentsOriginalColors = originalColors;

            const visited = new Set();
            const components = [];

            // –û–±—Ö–æ–¥ (–∏—Å–ø–æ–ª—å–∑—É–µ–º BFS/DFS, —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞—è –≥—Ä–∞—Ñ –∫–∞–∫ –Ω–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π) [web:187]
            for (const start of vertices) {
                if (visited.has(start)) continue;
                const queue = [start];
                const component = [];

                visited.add(start);
                while (queue.length > 0) {
                    const v = queue.shift();
                    component.push(v);

                    for (const edge of state.graph.edges) {
                        let neighbor = null;
                        if (edge.from === v) neighbor = edge.to;
                        else if (!edge.isDirected && edge.to === v) neighbor = edge.from;

                        if (neighbor !== null && !visited.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push(neighbor);
                        }
                    }
                }

                components.push(component);
            }

            // –ü–∞–ª–∏—Ç—Ä–∞ —Ü–≤–µ—Ç–æ–≤ –¥–ª—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
            const palette = [
                '#e6194b', // –∫—Ä–∞—Å–Ω—ã–π
                '#3cb44b', // –∑–µ–ª—ë–Ω—ã–π
                '#4363d8', // —Å–∏–Ω–∏–π
                '#f58231', // –æ—Ä–∞–Ω–∂–µ–≤—ã–π
                '#911eb4', // —Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π
                '#46f0f0', // –±–∏—Ä—é–∑–æ–≤—ã–π
                '#f032e6', // —Ä–æ–∑–æ–≤—ã–π
                '#bcf60c', // —Å–∞–ª–∞—Ç–æ–≤—ã–π
                '#fabebe', // —Å–≤–µ—Ç–ª–æ-—Ä–æ–∑–æ–≤—ã–π
                '#008080'  // —Ç—ë–º–Ω—ã–π –±–∏—Ä—é–∑–æ–≤—ã–π
            ];

            // –ö—Ä–∞—Å–∏–º –∫–∞–∂–¥—É—é –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—É –≤ —Å–≤–æ–π —Ü–≤–µ—Ç
            components.forEach((comp, index) => {
                const color = palette[index % palette.length];
                comp.forEach(id => {
                    const v = state.graph.vertices.get(id);
                    if (v) v.color = color;
                });
            });

            // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é
            state.algoCurrent = null;
            state.algoNext = null;
            render();

            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
            const compStr = components
                .map((comp, i) =>
                    `${i + 1}: {` + comp
                        .map(id => state.graph.vertices.get(id)?.label || id)
                        .join(', ') + '}')
                .join('\n');
            alert('–ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Å–≤—è–∑–Ω–æ—Å—Ç–∏:\n' + compStr);
        }

        // –®–∞—Ä–Ω–∏—Ä—ã –∏ –º–æ—Å—Ç—ã
        function tarjanArticulationAndBridges() {
            const ids = new Map();      // –≤—Ä–µ–º—è –≤—Ö–æ–¥–∞ –≤ –≤–µ—Ä—à–∏–Ω—É
            const low = new Map();      // –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –¥–æ—Å—Ç–∏–∂–∏–º–æ–µ –≤—Ä–µ–º—è
            const visited = new Set();
            let time = 0;

            const cutVertices = new Set(); // —à–∞—Ä–Ω–∏—Ä—ã
            const bridges = [];            // —Å–ø–∏—Å–æ–∫ –º–æ—Å—Ç–æ–≤ (–ø–∞—Ä—ã id –≤–µ—Ä—à–∏–Ω)

            function dfs(at, parent = null) {
                visited.add(at);
                ids.set(at, time);
                low.set(at, time);
                time++;

                let children = 0;

                for (const edge of state.graph.edges) {
                    // —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º –≥—Ä–∞—Ñ –∫–∞–∫ –Ω–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
                    let to = null;
                    if (edge.from === at) to = edge.to;
                    else if (!edge.isDirected && edge.to === at) to = edge.from;

                    if (to === null) continue;
                    if (to === parent) continue;

                    if (!visited.has(to)) {
                        children++;
                        dfs(to, at);

                        low.set(at, Math.min(low.get(at), low.get(to)));

                        // —É—Å–ª–æ–≤–∏–µ –º–æ—Å—Ç–∞
                        if (low.get(to) > ids.get(at)) {
                            bridges.push({ from: at, to });
                        }

                        // —É—Å–ª–æ–≤–∏–µ —à–∞—Ä–Ω–∏—Ä–∞ (–Ω–µ –∫–æ—Ä–µ–Ω—å)
                        if (parent !== null && low.get(to) >= ids.get(at)) {
                            cutVertices.add(at);
                        }
                    } else {
                        // –æ–±—Ä–∞—Ç–Ω–æ–µ —Ä–µ–±—Ä–æ
                        low.set(at, Math.min(low.get(at), ids.get(to)));
                    }
                }

                // –∫–æ—Ä–µ–Ω—å DFS‚Äë–¥–µ—Ä–µ–≤–∞ ‚Äî —à–∞—Ä–Ω–∏—Ä, –µ—Å–ª–∏ –∏–º–µ–µ—Ç –±–æ–ª–µ–µ –æ–¥–Ω–æ–≥–æ —Ä–µ–±—ë–Ω–∫–∞ [web:187]
                if (parent === null && children > 1) {
                    cutVertices.add(at);
                }
            }

            for (const [id] of state.graph.vertices) {
                if (!visited.has(id)) dfs(id, null);
            }

            return { cutVertices, bridges };
        }

        function findCutVertices() {
            if (state.graph.vertices.size === 0) {
                alert('–ì—Ä–∞—Ñ –ø—É—Å—Ç');
                return;
            }

            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â—É—é –ø–æ–¥—Å–≤–µ—Ç–∫—É
            state.highlightedVertices = [];
            state.highlightedPath = [];
            state.algoCurrent = null;
            state.algoNext = null;

            const { cutVertices } = tarjanArticulationAndBridges();

            // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —à–∞—Ä–Ω–∏—Ä–æ–≤ –∫—Ä–∞—Å–Ω—ã–º: –∏—Å–ø–æ–ª—å–∑—É–µ–º highlightedVertices,
            // –∞ –≤ drawVertex —É–∂–µ –ø—Ä–µ–¥—É—Å–º–æ—Ç—Ä–µ–Ω —Ü–≤–µ—Ç –¥–ª—è –Ω–∏—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, #a84b2f),
            // –ª–∏–±–æ –º–æ–∂–Ω–æ –≤—Ä–µ–º–µ–Ω–Ω–æ –º–µ–Ω—è—Ç—å v.color, –µ—Å–ª–∏ —Ö–æ—á–µ—à—å –∏–º–µ–Ω–Ω–æ –∫—Ä–∞—Å–Ω—ã–π.
            state.highlightedVertices = Array.from(cutVertices);

            render();

            const list = Array.from(cutVertices).map(id =>
                state.graph.vertices.get(id)?.label || id
            );
            alert(
                cutVertices.size === 0
                    ? '–®–∞—Ä–Ω–∏—Ä–æ–≤ –Ω–µ—Ç'
                    : '–ù–∞–π–¥–µ–Ω–Ω—ã–µ —à–∞—Ä–Ω–∏—Ä—ã (cut vertices):\n' + list.join(', ')
            );
        }

        function findBridges() {
            if (state.graph.vertices.size === 0) {
                alert('–ì—Ä–∞—Ñ –ø—É—Å—Ç');
                return;
            }

            state.highlightedVertices = [];
            state.highlightedPath = [];
            state.algoCurrent = null;
            state.algoNext = null;

            const { bridges } = tarjanArticulationAndBridges();

            // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –º–æ—Å—Ç–æ–≤ –∫—Ä–∞—Å–Ω—ã–º: —Å–æ–±–∏—Ä–∞–µ–º –∏–Ω–¥–µ–∫—Å—ã —Ä—ë–±–µ—Ä –≤ highlightedPath
            const bridgeEdges = [];
            for (let i = 0; i < state.graph.edges.length; i++) {
                const e = state.graph.edges[i];
                if (bridges.some(b =>
                    (b.from === e.from && b.to === e.to) ||
                    (!e.isDirected && b.from === e.to && b.to === e.from)
                )) {
                    bridgeEdges.push(i);
                }
            }
            state.highlightedPath = bridgeEdges;

            render();

            const list = bridges.map(b => {
                const v1 = state.graph.vertices.get(b.from);
                const v2 = state.graph.vertices.get(b.to);
                const l1 = v1?.label || b.from;
                const l2 = v2?.label || b.to;
                return `${l1} ‚Äî ${l2}`;
            });

            alert(
                bridges.length === 0
                    ? '–ú–æ—Å—Ç–æ–≤ –Ω–µ—Ç'
                    : '–ù–∞–π–¥–µ–Ω–Ω—ã–µ –º–æ—Å—Ç—ã (bridges):\n' + list.join('\n')
            );
        }

        // ============ –§–ê–ô–õ–´ ============

        function saveGraph() {
            // –î–∏–∞–ª–æ–≥ –¥–ª—è –≤–≤–æ–¥–∞ –Ω–∞–∑–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞
            const filename = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞:', 'graph');
            if (filename === null) return; // –û—Ç–º–µ–Ω–∞

            const data = state.graph.toJSON();
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename.trim() === '' ? 'graph.json' : filename + '.json'; // –ï—Å–ª–∏ –ø—É—Å—Ç–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º 'graph.json'
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportCanvas() {
            // –î–∏–∞–ª–æ–≥ –¥–ª—è –≤–≤–æ–¥–∞ –Ω–∞–∑–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞
            const filename = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞:', 'graph');
            if (filename === null) return; // –û—Ç–º–µ–Ω–∞

            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = filename.trim() === '' ? 'graph.png' : filename + '.png'; // –ï—Å–ª–∏ –ø—É—Å—Ç–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º 'graph.png'
            link.click();
        }

        // ============ –†–ê–ë–û–¢–ê –° –ú–ê–¢–†–ò–¶–ï–ô –í–ï–°–û–í ============

        function openMatrixModal() {
            document.getElementById('matrixInput').value = '';
            document.getElementById('vertexLabelsInput').value = '';
            document.getElementById('isDirectedMatrixInput').checked = false;
            document.getElementById('matrixModal').classList.add('active');
        }

        function closeMatrixModal() {
            document.getElementById('matrixModal').classList.remove('active');
        }

        function confirmLoadMatrix() {
            const matrixText = document.getElementById('matrixInput').value.trim();
            const labelsText = document.getElementById('vertexLabelsInput').value.trim();
            const isDirected = document.getElementById('isDirectedMatrixInput').checked;

            if (!matrixText) {
                alert('–í–≤–µ–¥–∏—Ç–µ –º–∞—Ç—Ä–∏—Ü—É –≤–µ—Å–æ–≤');
                return;
            }

            try {
                // –ü–∞—Ä—Å–∏–Ω–≥ –º–∞—Ç—Ä–∏—Ü—ã
                const lines = matrixText.split('\n').map(line => 
                    line.trim().split(/\s+/).map(Number)
                ).filter(line => line.length > 0);

                const size = lines.length;

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –º–∞—Ç—Ä–∏—Ü—ã
                for (let line of lines) {
                    if (line.length !== size) {
                        alert('–ú–∞—Ç—Ä–∏—Ü–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∫–≤–∞–¥—Ä–∞—Ç–Ω–æ–π!');
                        return;
                    }
                }

                // –ü–∞—Ä—Å–∏–Ω–≥ –º–µ—Ç–∞–∫ –≤–µ—Ä—à–∏–Ω
                const labels = labelsText ? 
                    labelsText.split(',').map(l => l.trim()) : 
                    Array.from({length: size}, (_, i) => `V${i}`);

                if (labels.length !== size) {
                    alert(`–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Ç–∞–∫ (${labels.length}) –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å —Ä–∞–∑–º–µ—Ä–æ–º –º–∞—Ç—Ä–∏—Ü—ã (${size})`);
                    return;
                }

                // –û—á–∏—Å—Ç–∫–∞ –≥—Ä–∞—Ñ–∞
                state.graph.clear();
                state.selectedVertex = null;
                state.selectedEdge = null;
                state.highlightedPath = [];
                state.highlightedVertices = [];

                // –°–æ–∑–¥–∞–Ω–∏–µ –≤–µ—Ä—à–∏–Ω
                for (let i = 0; i < size; i++) {
                    state.graph.addVertex(i.toString(), labels[i], i * 100 - (size * 50), 0);
                }

                // –°–æ–∑–¥–∞–Ω–∏–µ —Ä—ë–±–µ—Ä –∏–∑ –º–∞—Ç—Ä–∏—Ü—ã
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        const weight = lines[i][j];
                        if (weight !== 0 && weight !== undefined) {
                            // –î–ª—è –Ω–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞ –∏–∑–±–µ–≥–∞–µ–º –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
                            if (isDirected || i <= j) {
                                state.graph.addEdge(i.toString(), j.toString(), weight, 
                                                weight.toString(), '#626c7c', 2, isDirected);
                            }
                        }
                    }
                }

                updateStatus();
                render();
                closeMatrixModal();
                alert('–ì—Ä–∞—Ñ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω –∏–∑ –º–∞—Ç—Ä–∏—Ü—ã');

            } catch (error) {
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ –º–∞—Ç—Ä–∏—Ü—ã: ' + error.message);
            }
        }

        function loadGraphFromMatrix() {
            openMatrixModal();
        }

        function saveGraphAsMatrix() {
            const vertices = Array.from(state.graph.vertices.values());
            const size = vertices.length;

            if (size === 0) {
                alert('–ì—Ä–∞—Ñ –ø—É—Å—Ç');
                return;
            }

            // –°–æ–∑–¥–∞–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã
            const matrix = Array(size).fill(null).map(() => Array(size).fill(0));

            // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –≤–µ—Å–∞–º–∏
            for (let edge of state.graph.edges) {
                const fromIdx = Array.from(state.graph.vertices.keys()).indexOf(edge.from);
                const toIdx = Array.from(state.graph.vertices.keys()).indexOf(edge.to);

                if (fromIdx !== -1 && toIdx !== -1) {
                    matrix[fromIdx][toIdx] = edge.weight;

                    // –î–ª—è –Ω–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ä—ë–±–µ—Ä –¥–æ–±–∞–≤–ª—è–µ–º —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                    if (!edge.isDirected) {
                        matrix[toIdx][fromIdx] = edge.weight;
                    }
                }
            }

            // –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –≤ —Å—Ç—Ä–æ–∫—É
            let matrixText = '–ú–∞—Ç—Ä–∏—Ü–∞ –≤–µ—Å–æ–≤ –≥—Ä–∞—Ñ–∞\n';
            matrixText += '–í–µ—Ä—à–∏–Ω—ã: ' + vertices.map(v => v.label).join(', ') + '\n\n';

            for (let i = 0; i < size; i++) {
                matrixText += matrix[i].map(val => 
                    val === 0 ? '0' : val.toFixed(2)
                ).join('\t') + '\n';
            }

            // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ —Ñ–∞–π–ª
            const filename = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞:', 'graph_matrix');
            if (filename === null) return;

            const blob = new Blob([matrixText], { type: 'text/plain; charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename.trim() === '' ? 'graph_matrix.txt' : filename + '.txt';
            a.click();
            URL.revokeObjectURL(url);

            alert('–ú–∞—Ç—Ä–∏—Ü–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ —Ñ–∞–π–ª');
        }



        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        updateStatus();
        updateZoomDisplay();
    </script>
</body>
</html>
